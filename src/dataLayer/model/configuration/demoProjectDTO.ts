export const username = 'socketio';
export const repository = 'socket.io-client-java';
export const unprocessedDemoProject = {
  "directory": {
    "path": "/",
    "content": [
      {
        "directory": {
          "path": "src",
          "content": [
            {
              "directory": {
                "path": "main",
                "content": [
                  {
                    "directory": {
                      "path": "java",
                      "content": [
                        {
                          "directory": {
                            "path": "io",
                            "content": [
                              {
                                "directory": {
                                  "path": "socket",
                                  "content": [
                                    {
                                      "directory": {
                                        "path": "backo",
                                        "content": [
                                          {
                                            "javaFile": {
                                              "path": "Backoff.java",
                                              "content": "package io.socket.backo;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\n/**\n * Imported from https://github.com/mokesmokes/backo\n */\npublic class Backoff {\n\n    private long ms = 100;\n    private long max = 10000;\n    private int factor = 2;\n    private double jitter;\n    private int attempts;\n\n    public Backoff() {}\n\n    public long duration() {\n        BigInteger ms = BigInteger.valueOf(this.ms)\n                .multiply(BigInteger.valueOf(this.factor).pow(this.attempts++));\n        if (jitter != 0.0) {\n            double rand = Math.random();\n            BigInteger deviation = BigDecimal.valueOf(rand)\n                    .multiply(BigDecimal.valueOf(jitter))\n                    .multiply(new BigDecimal(ms)).toBigInteger();\n            ms = (((int) Math.floor(rand * 10)) & 1) == 0 ? ms.subtract(deviation) : ms.add(deviation);\n        }\n        return ms\n                .min(BigInteger.valueOf(this.max))\n                .max(BigInteger.valueOf(this.ms))\n                .longValue();\n    }\n\n    public void reset() {\n        this.attempts = 0;\n    }\n\n    public Backoff setMin(long min) {\n        this.ms = min;\n        return this;\n    }\n\n    public Backoff setMax(long max) {\n        this.max = max;\n        return this;\n    }\n\n    public Backoff setFactor(int factor) {\n        this.factor = factor;\n        return this;\n    }\n\n    public Backoff setJitter(double jitter) {\n        boolean isValid = jitter >= 0 && jitter < 1;\n        if (!isValid) {\n            throw new IllegalArgumentException(\"jitter must be between 0 and 1\");\n        }\n        this.jitter = jitter;\n        return this;\n    }\n\n    public int getAttempts() {\n        return this.attempts;\n    }\n}\n"
                                            }
                                          }
                                        ]
                                      }
                                    },
                                    {
                                      "directory": {
                                        "path": "client",
                                        "content": [
                                          {
                                            "javaFile": {
                                              "path": "Ack.java",
                                              "content": "package io.socket.client;\n\n/**\n * Acknowledgement.\n */\npublic interface Ack {\n\n    void call(Object... args);\n\n}\n\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "AckWithTimeout.java",
                                              "content": "package io.socket.client;\n\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic abstract class AckWithTimeout implements Ack {\n    private final long timeout;\n    private final Timer timer = new Timer();\n\n    /**\n     *\n     * @param timeout delay in milliseconds\n     */\n    public AckWithTimeout(long timeout) {\n        this.timeout = timeout;\n    }\n\n    @Override\n    public final void call(Object... args) {\n        this.timer.cancel();\n        this.onSuccess(args);\n    }\n\n    public final void schedule(TimerTask task) {\n        this.timer.schedule(task, this.timeout);\n    }\n\n    public final void cancelTimer() {\n        this.timer.cancel();\n    }\n\n    public abstract void onSuccess(Object... args);\n    public abstract void onTimeout();\n\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "IO.java",
                                              "content": "package io.socket.client;\n\n\nimport io.socket.parser.Parser;\nimport okhttp3.Call;\nimport okhttp3.WebSocket;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n\npublic class IO {\n\n    private static final Logger logger = Logger.getLogger(IO.class.getName());\n\n    private static final ConcurrentHashMap<String, Manager> managers = new ConcurrentHashMap<>();\n\n    /**\n     * Protocol version.\n     */\n    public static int protocol = Parser.protocol;\n\n    public static void setDefaultOkHttpWebSocketFactory(WebSocket.Factory factory) {\n        Manager.defaultWebSocketFactory = factory;\n    }\n\n    public static void setDefaultOkHttpCallFactory(Call.Factory factory) {\n        Manager.defaultCallFactory = factory;\n    }\n\n    private IO() {}\n\n    public static Socket socket(String uri) throws URISyntaxException {\n        return socket(uri, null);\n    }\n\n    public static Socket socket(String uri, Options opts) throws URISyntaxException {\n        return socket(new URI(uri), opts);\n    }\n\n    public static Socket socket(URI uri) {\n        return socket(uri, null);\n    }\n\n    /**\n     * Initializes a {@link Socket} from an existing {@link Manager} for multiplexing.\n     *\n     * @param uri uri to connect.\n     * @param opts options for socket.\n     * @return {@link Socket} instance.\n     */\n    public static Socket socket(URI uri, Options opts) {\n        if (opts == null) {\n            opts = new Options();\n        }\n\n        Url.ParsedURI parsed = Url.parse(uri);\n        URI source = parsed.uri;\n        String id = parsed.id;\n\n        boolean sameNamespace = managers.containsKey(id)\n                && managers.get(id).nsps.containsKey(source.getPath());\n        boolean newConnection = opts.forceNew || !opts.multiplex || sameNamespace;\n        Manager io;\n\n        String query = source.getQuery();\n        if (query != null && (opts.query == null || opts.query.isEmpty())) {\n            opts.query = query;\n        }\n\n        if (newConnection) {\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(String.format(\"ignoring socket cache for %s\", source));\n            }\n            io = new Manager(source, opts);\n        } else {\n            if (!managers.containsKey(id)) {\n                if (logger.isLoggable(Level.FINE)) {\n                    logger.fine(String.format(\"new io instance for %s\", source));\n                }\n                managers.putIfAbsent(id, new Manager(source, opts));\n            }\n            io = managers.get(id);\n        }\n\n        return io.socket(source.getPath(), opts);\n    }\n\n\n    public static class Options extends Manager.Options {\n\n        public boolean forceNew;\n\n        /**\n         * Whether to enable multiplexing. Default is true.\n         */\n        public boolean multiplex = true;\n\n        /**\n         * <p>\n         *   Retrieve new builder class that helps creating socket option as builder pattern.\n         *   This method returns exactly same result as :\n         * </p>\n         * <code>\n         * SocketOptionBuilder builder = SocketOptionBuilder.builder();\n         * </code>\n         *\n         * @return builder class that helps creating socket option as builder pattern.\n         * @see SocketOptionBuilder#builder()\n         */\n        public static SocketOptionBuilder builder() {\n            return SocketOptionBuilder.builder();\n        }\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "Manager.java",
                                              "content": "package io.socket.client;\n\nimport io.socket.backo.Backoff;\nimport io.socket.emitter.Emitter;\nimport io.socket.parser.DecodingException;\nimport io.socket.parser.IOParser;\nimport io.socket.parser.Packet;\nimport io.socket.parser.Parser;\nimport io.socket.thread.EventThread;\nimport okhttp3.Call;\nimport okhttp3.WebSocket;\n\nimport java.net.URI;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Manager class represents a connection to a given Socket.IO server.\n */\npublic class Manager extends Emitter {\n\n    private static final Logger logger = Logger.getLogger(Manager.class.getName());\n\n    /*package*/ enum ReadyState {\n        CLOSED, OPENING, OPEN\n    }\n\n    /**\n     * Called on a successful connection.\n     */\n    public static final String EVENT_OPEN = \"open\";\n\n    /**\n     * Called on a disconnection.\n     */\n    public static final String EVENT_CLOSE = \"close\";\n\n    public static final String EVENT_PACKET = \"packet\";\n    public static final String EVENT_ERROR = \"error\";\n\n    /**\n     * Called on a successful reconnection.\n     */\n    public static final String EVENT_RECONNECT = \"reconnect\";\n\n    /**\n     * Called on a reconnection attempt error.\n     */\n    public static final String EVENT_RECONNECT_ERROR = \"reconnect_error\";\n\n    public static final String EVENT_RECONNECT_FAILED = \"reconnect_failed\";\n\n    public static final String EVENT_RECONNECT_ATTEMPT = \"reconnect_attempt\";\n\n    /**\n     * Called when a new transport is created. (experimental)\n     */\n    public static final String EVENT_TRANSPORT = Engine.EVENT_TRANSPORT;\n\n    /*package*/ static WebSocket.Factory defaultWebSocketFactory;\n    /*package*/ static Call.Factory defaultCallFactory;\n\n    /*package*/ ReadyState readyState;\n\n    private boolean _reconnection;\n    private boolean skipReconnect;\n    private boolean reconnecting;\n    private boolean encoding;\n    private int _reconnectionAttempts;\n    private long _reconnectionDelay;\n    private long _reconnectionDelayMax;\n    private double _randomizationFactor;\n    private Backoff backoff;\n    private long _timeout;\n    private URI uri;\n    private List<Packet> packetBuffer;\n    private Queue<On.Handle> subs;\n    private Options opts;\n    /*package*/ io.socket.engineio.client.Socket engine;\n    private Parser.Encoder encoder;\n    private Parser.Decoder decoder;\n\n    /**\n     * This HashMap can be accessed from outside of EventThread.\n     */\n    /*package*/ ConcurrentHashMap<String, Socket> nsps;\n\n\n    public Manager() {\n        this(null, null);\n    }\n\n    public Manager(URI uri) {\n        this(uri, null);\n    }\n\n    public Manager(Options opts) {\n        this(null, opts);\n    }\n\n    public Manager(URI uri, Options opts) {\n        if (opts == null) {\n            opts = new Options();\n        }\n        if (opts.path == null) {\n            opts.path = \"/socket.io\";\n        }\n        if (opts.webSocketFactory == null) {\n            opts.webSocketFactory = defaultWebSocketFactory;\n        }\n        if (opts.callFactory == null) {\n            opts.callFactory = defaultCallFactory;\n        }\n        this.opts = opts;\n        this.nsps = new ConcurrentHashMap<>();\n        this.subs = new LinkedList<>();\n        this.reconnection(opts.reconnection);\n        this.reconnectionAttempts(opts.reconnectionAttempts != 0 ? opts.reconnectionAttempts : Integer.MAX_VALUE);\n        this.reconnectionDelay(opts.reconnectionDelay != 0 ? opts.reconnectionDelay : 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax != 0 ? opts.reconnectionDelayMax : 5000);\n        this.randomizationFactor(opts.randomizationFactor != 0.0 ? opts.randomizationFactor : 0.5);\n        this.backoff = new Backoff()\n                .setMin(this.reconnectionDelay())\n                .setMax(this.reconnectionDelayMax())\n                .setJitter(this.randomizationFactor());\n        this.timeout(opts.timeout);\n        this.readyState = ReadyState.CLOSED;\n        this.uri = uri;\n        this.encoding = false;\n        this.packetBuffer = new ArrayList<>();\n        this.encoder = opts.encoder != null ? opts.encoder : new IOParser.Encoder();\n        this.decoder = opts.decoder != null ? opts.decoder : new IOParser.Decoder();\n    }\n\n    public boolean reconnection() {\n        return this._reconnection;\n    }\n\n    public Manager reconnection(boolean v) {\n        this._reconnection = v;\n        return this;\n    }\n\n    public boolean isReconnecting() {\n        return reconnecting;\n    }\n\n    public int reconnectionAttempts() {\n        return this._reconnectionAttempts;\n    }\n\n    public Manager reconnectionAttempts(int v) {\n        this._reconnectionAttempts = v;\n        return this;\n    }\n\n    public final long reconnectionDelay() {\n        return this._reconnectionDelay;\n    }\n\n    public Manager reconnectionDelay(long v) {\n        this._reconnectionDelay = v;\n        if (this.backoff != null) {\n            this.backoff.setMin(v);\n        }\n        return this;\n    }\n\n    public final double randomizationFactor() {\n        return this._randomizationFactor;\n    }\n\n    public Manager randomizationFactor(double v) {\n        this._randomizationFactor = v;\n        if (this.backoff != null) {\n            this.backoff.setJitter(v);\n        }\n        return this;\n    }\n\n    public final long reconnectionDelayMax() {\n        return this._reconnectionDelayMax;\n    }\n\n    public Manager reconnectionDelayMax(long v) {\n        this._reconnectionDelayMax = v;\n        if (this.backoff != null) {\n            this.backoff.setMax(v);\n        }\n        return this;\n    }\n\n    public long timeout() {\n        return this._timeout;\n    }\n\n    public Manager timeout(long v) {\n        this._timeout = v;\n        return this;\n    }\n\n    private void maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this.reconnecting && this._reconnection && this.backoff.getAttempts() == 0) {\n            this.reconnect();\n        }\n    }\n\n    public Manager open(){\n        return open(null);\n    }\n\n    /**\n     * Connects the client.\n     *\n     * @param fn callback.\n     * @return a reference to this object.\n     */\n    public Manager open(final OpenCallback fn) {\n        EventThread.exec(new Runnable() {\n            @Override\n            public void run() {\n                if (logger.isLoggable(Level.FINE)) {\n                    logger.fine(String.format(\"readyState %s\", Manager.this.readyState));\n                }\n                if (Manager.this.readyState == ReadyState.OPEN || Manager.this.readyState == ReadyState.OPENING) return;\n\n                if (logger.isLoggable(Level.FINE)) {\n                    logger.fine(String.format(\"opening %s\", Manager.this.uri));\n                }\n                Manager.this.engine = new Engine(Manager.this.uri, Manager.this.opts);\n                final io.socket.engineio.client.Socket socket = Manager.this.engine;\n                final Manager self = Manager.this;\n                Manager.this.readyState = ReadyState.OPENING;\n                Manager.this.skipReconnect = false;\n\n                // propagate transport event.\n                socket.on(Engine.EVENT_TRANSPORT, new Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        self.emit(Manager.EVENT_TRANSPORT, args);\n                    }\n                });\n\n                final On.Handle openSub = On.on(socket, Engine.EVENT_OPEN, new Listener() {\n                    @Override\n                    public void call(Object... objects) {\n                        self.onopen();\n                        if (fn != null) fn.call(null);\n                    }\n                });\n\n                On.Handle errorSub = On.on(socket, Engine.EVENT_ERROR, new Listener() {\n                    @Override\n                    public void call(Object... objects) {\n                        Object data = objects.length > 0 ? objects[0] : null;\n                        logger.fine(\"connect_error\");\n                        self.cleanup();\n                        self.readyState = ReadyState.CLOSED;\n                        self.emit(EVENT_ERROR, data);\n                        if (fn != null) {\n                            Exception err = new SocketIOException(\"Connection error\",\n                                    data instanceof Exception ? (Exception) data : null);\n                            fn.call(err);\n                        } else {\n                            // Only do this if there is no fn to handle the error\n                            self.maybeReconnectOnOpen();\n                        }\n                    }\n                });\n\n                final long timeout = Manager.this._timeout;\n                final Runnable onTimeout = new Runnable() {\n                    @Override\n                    public void run() {\n                        logger.fine(String.format(\"connect attempt timed out after %d\", timeout));\n                        openSub.destroy();\n                        socket.close();\n                        socket.emit(Engine.EVENT_ERROR, new SocketIOException(\"timeout\"));\n                    }\n                };\n\n                if (timeout == 0) {\n                    EventThread.exec(onTimeout);\n                    return;\n                } else if (Manager.this._timeout > 0) {\n                    logger.fine(String.format(\"connection attempt will timeout after %d\", timeout));\n\n                    final Timer timer = new Timer();\n                    timer.schedule(new TimerTask() {\n                        @Override\n                        public void run() {\n                            EventThread.exec(onTimeout);\n                        }\n                    }, timeout);\n\n                    Manager.this.subs.add(new On.Handle() {\n                        @Override\n                        public void destroy() {\n                            timer.cancel();\n                        }\n                    });\n                }\n\n                Manager.this.subs.add(openSub);\n                Manager.this.subs.add(errorSub);\n\n                Manager.this.engine.open();\n            }\n        });\n        return this;\n    }\n\n    private void onopen() {\n        logger.fine(\"open\");\n\n        this.cleanup();\n\n        this.readyState = ReadyState.OPEN;\n        this.emit(EVENT_OPEN);\n\n        final io.socket.engineio.client.Socket socket = this.engine;\n        this.subs.add(On.on(socket, Engine.EVENT_DATA, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Object data = objects[0];\n                try {\n                    if (data instanceof String) {\n                        Manager.this.decoder.add((String) data);\n                    } else if (data instanceof byte[]) {\n                        Manager.this.decoder.add((byte[]) data);\n                    }\n                } catch (DecodingException e) {\n                    logger.fine(\"error while decoding the packet: \" + e.getMessage());\n                }\n            }\n        }));\n        this.subs.add(On.on(socket, Engine.EVENT_ERROR, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Manager.this.onerror((Exception)objects[0]);\n            }\n        }));\n        this.subs.add(On.on(socket, Engine.EVENT_CLOSE, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Manager.this.onclose((String)objects[0]);\n            }\n        }));\n        this.decoder.onDecoded(new Parser.Decoder.Callback() {\n            @Override\n            public void call (Packet packet) {\n                Manager.this.ondecoded(packet);\n            }\n        });\n    }\n\n    private void ondecoded(Packet packet) {\n        this.emit(EVENT_PACKET, packet);\n    }\n\n    private void onerror(Exception err) {\n        logger.log(Level.FINE, \"error\", err);\n        this.emit(EVENT_ERROR, err);\n    }\n\n    /**\n     * Initializes {@link Socket} instances for each namespaces.\n     *\n     * @param nsp namespace.\n     * @param opts options.\n     * @return a socket instance for the namespace.\n     */\n    public Socket socket(final String nsp, Options opts) {\n        synchronized (this.nsps) {\n            Socket socket = this.nsps.get(nsp);\n            if (socket == null) {\n                socket = new Socket(this, nsp, opts);\n                this.nsps.put(nsp, socket);\n            }\n            return socket;\n        }\n    }\n\n    public Socket socket(String nsp) {\n        return socket(nsp, null);\n    }\n\n    /*package*/ void destroy() {\n        synchronized (this.nsps) {\n            for (Socket socket : this.nsps.values()) {\n                if (socket.isActive()) {\n                    logger.fine(\"socket is still active, skipping close\");\n                    return;\n                }\n            }\n\n            this.close();\n        }\n    }\n\n    /*package*/ void packet(Packet packet) {\n        if (logger.isLoggable(Level.FINE)) {\n            logger.fine(String.format(\"writing packet %s\", packet));\n        }\n        final Manager self = this;\n\n        if (!self.encoding) {\n            self.encoding = true;\n            this.encoder.encode(packet, new Parser.Encoder.Callback() {\n                @Override\n                public void call(Object[] encodedPackets) {\n                    for (Object packet : encodedPackets) {\n                        if (packet instanceof String) {\n                            self.engine.write((String)packet);\n                        } else if (packet instanceof byte[]) {\n                            self.engine.write((byte[])packet);\n                        }\n                    }\n                    self.encoding = false;\n                    self.processPacketQueue();\n                }\n            });\n        } else {\n            self.packetBuffer.add(packet);\n        }\n    }\n\n    private void processPacketQueue() {\n        if (!this.packetBuffer.isEmpty() && !this.encoding) {\n            Packet pack = this.packetBuffer.remove(0);\n            this.packet(pack);\n        }\n    }\n\n    private void cleanup() {\n        logger.fine(\"cleanup\");\n\n        On.Handle sub;\n        while ((sub = this.subs.poll()) != null) sub.destroy();\n        this.decoder.onDecoded(null);\n\n        this.packetBuffer.clear();\n        this.encoding = false;\n\n        this.decoder.destroy();\n    }\n\n    /*package*/ void close() {\n        logger.fine(\"disconnect\");\n        this.skipReconnect = true;\n        this.reconnecting = false;\n        if (this.readyState != ReadyState.OPEN) {\n            // `onclose` will not fire because\n            // an open event never happened\n            this.cleanup();\n        }\n        this.backoff.reset();\n        this.readyState = ReadyState.CLOSED;\n        if (this.engine != null) {\n            this.engine.close();\n        }\n    }\n\n    private void onclose(String reason) {\n        logger.fine(\"onclose\");\n        this.cleanup();\n        this.backoff.reset();\n        this.readyState = ReadyState.CLOSED;\n        this.emit(EVENT_CLOSE, reason);\n\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n\n    private void reconnect() {\n        if (this.reconnecting || this.skipReconnect) return;\n\n        final Manager self = this;\n\n        if (this.backoff.getAttempts() >= this._reconnectionAttempts) {\n            logger.fine(\"reconnect failed\");\n            this.backoff.reset();\n            this.emit(EVENT_RECONNECT_FAILED);\n            this.reconnecting = false;\n        } else {\n            long delay = this.backoff.duration();\n            logger.fine(String.format(\"will wait %dms before reconnect attempt\", delay));\n\n            this.reconnecting = true;\n            final Timer timer = new Timer();\n            timer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    EventThread.exec(new Runnable() {\n                        @Override\n                        public void run() {\n                            if (self.skipReconnect) return;\n\n                            logger.fine(\"attempting reconnect\");\n                            int attempts = self.backoff.getAttempts();\n                            self.emit(EVENT_RECONNECT_ATTEMPT, attempts);\n\n                            // check again for the case socket closed in above events\n                            if (self.skipReconnect) return;\n\n                            self.open(new OpenCallback() {\n                                @Override\n                                public void call(Exception err) {\n                                    if (err != null) {\n                                        logger.fine(\"reconnect attempt error\");\n                                        self.reconnecting = false;\n                                        self.reconnect();\n                                        self.emit(EVENT_RECONNECT_ERROR, err);\n                                    } else {\n                                        logger.fine(\"reconnect success\");\n                                        self.onreconnect();\n                                    }\n                                }\n                            });\n                        }\n                    });\n                }\n            }, delay);\n\n            this.subs.add(new On.Handle() {\n                @Override\n                public void destroy() {\n                    timer.cancel();\n                }\n            });\n        }\n    }\n\n    private void onreconnect() {\n        int attempts = this.backoff.getAttempts();\n        this.reconnecting = false;\n        this.backoff.reset();\n        this.emit(EVENT_RECONNECT, attempts);\n    }\n\n\n    public interface OpenCallback {\n\n        void call(Exception err);\n    }\n\n\n    private static class Engine extends io.socket.engineio.client.Socket {\n\n        Engine(URI uri, Options opts) {\n            super(uri, opts);\n        }\n    }\n\n    public static class Options extends io.socket.engineio.client.Socket.Options {\n\n        public boolean reconnection = true;\n        public int reconnectionAttempts;\n        public long reconnectionDelay;\n        public long reconnectionDelayMax;\n        public double randomizationFactor;\n        public Parser.Encoder encoder;\n        public Parser.Decoder decoder;\n        public Map<String, String> auth;\n\n        /**\n         * Connection timeout (ms). Set -1 to disable.\n         */\n        public long timeout = 20000;\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "On.java",
                                              "content": "package io.socket.client;\n\nimport io.socket.emitter.Emitter;\n\npublic class On {\n\n    private On() {}\n\n    public static Handle on(final Emitter obj, final String ev, final Emitter.Listener fn) {\n        obj.on(ev, fn);\n        return new Handle() {\n            @Override\n            public void destroy() {\n                obj.off(ev, fn);\n            }\n        };\n    }\n\n    public interface Handle {\n\n        void destroy();\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "Socket.java",
                                              "content": "package io.socket.client;\n\nimport io.socket.emitter.Emitter;\nimport io.socket.parser.Packet;\nimport io.socket.parser.Parser;\nimport io.socket.thread.EventThread;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.util.*;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The socket class for Socket.IO Client.\n */\npublic class Socket extends Emitter {\n\n    private static final Logger logger = Logger.getLogger(Socket.class.getName());\n\n    /**\n     * Called on a connection.\n     */\n    public static final String EVENT_CONNECT = \"connect\";\n\n    /**\n     * Called on a disconnection.\n     */\n    public static final String EVENT_DISCONNECT = \"disconnect\";\n\n    /**\n     * Called on a connection error.\n     *\n     * <p>Parameters:</p>\n     * <ul>\n     *   <li>(Exception) error data.</li>\n     * </ul>\n     */\n    public static final String EVENT_CONNECT_ERROR = \"connect_error\";\n\n    static final String EVENT_MESSAGE = \"message\";\n\n    protected static Map<String, Integer> RESERVED_EVENTS = new HashMap<String, Integer>() {{\n        put(EVENT_CONNECT, 1);\n        put(EVENT_CONNECT_ERROR, 1);\n        put(EVENT_DISCONNECT, 1);\n        // used on the server-side\n        put(\"disconnecting\", 1);\n        put(\"newListener\", 1);\n        put(\"removeListener\", 1);\n    }};\n\n    /*package*/ String id;\n\n    private volatile boolean connected;\n    private int ids;\n    private String nsp;\n    private Manager io;\n    private Map<String, String> auth;\n    private Map<Integer, Ack> acks = new HashMap<>();\n    private Queue<On.Handle> subs;\n    private final Queue<List<Object>> receiveBuffer = new LinkedList<>();\n    private final Queue<Packet<JSONArray>> sendBuffer = new LinkedList<>();\n\n    private ConcurrentLinkedQueue<Listener> onAnyIncomingListeners = new ConcurrentLinkedQueue<>();\n    private ConcurrentLinkedQueue<Listener> onAnyOutgoingListeners = new ConcurrentLinkedQueue<>();\n\n    public Socket(Manager io, String nsp, Manager.Options opts) {\n        this.io = io;\n        this.nsp = nsp;\n        if (opts != null) {\n            this.auth = opts.auth;\n        }\n    }\n\n    private void subEvents() {\n        if (this.subs != null) return;\n\n        final Manager io = Socket.this.io;\n        Socket.this.subs = new LinkedList<On.Handle>() {{\n            add(On.on(io, Manager.EVENT_OPEN, new Listener() {\n                @Override\n                public void call(Object... args) {\n                    Socket.this.onopen();\n                }\n            }));\n            add(On.on(io, Manager.EVENT_PACKET, new Listener() {\n                @Override\n                public void call(Object... args) {\n                    Socket.this.onpacket((Packet<?>) args[0]);\n                }\n            }));\n            add(On.on(io, Manager.EVENT_ERROR, new Listener() {\n                @Override\n                public void call(Object... args) {\n                    if (!Socket.this.connected) {\n                        Socket.super.emit(EVENT_CONNECT_ERROR, args[0]);\n                    }\n                }\n            }));\n            add(On.on(io, Manager.EVENT_CLOSE, new Listener() {\n                @Override\n                public void call(Object... args) {\n                    Socket.this.onclose(args.length > 0 ? (String) args[0] : null);\n                }\n            }));\n        }};\n    }\n\n    public boolean isActive() {\n        return this.subs != null;\n    }\n\n    /**\n     * Connects the socket.\n     */\n    public Socket open() {\n        EventThread.exec(new Runnable() {\n            @Override\n            public void run() {\n                if (Socket.this.connected || Socket.this.io.isReconnecting()) return;\n\n                Socket.this.subEvents();\n                Socket.this.io.open(); // ensure open\n                if (Manager.ReadyState.OPEN == Socket.this.io.readyState) Socket.this.onopen();\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Connects the socket.\n     */\n    public Socket connect() {\n        return this.open();\n    }\n\n    /**\n     * Send messages.\n     *\n     * @param args data to send.\n     * @return a reference to this object.\n     */\n    public Socket send(final Object... args) {\n        EventThread.exec(new Runnable() {\n            @Override\n            public void run() {\n                Socket.this.emit(EVENT_MESSAGE, args);\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Emits an event. When you pass {@link Ack} at the last argument, then the acknowledge is done.\n     *\n     * @param event an event name.\n     * @param args data to send.\n     * @return a reference to this object.\n     */\n    @Override\n    public Emitter emit(final String event, final Object... args) {\n        if (RESERVED_EVENTS.containsKey(event)) {\n            throw new RuntimeException(\"'\" + event + \"' is a reserved event name\");\n        }\n\n        EventThread.exec(new Runnable() {\n            @Override\n            public void run() {\n                Ack ack;\n                Object[] _args;\n                int lastIndex = args.length - 1;\n\n                if (args.length > 0 && args[lastIndex] instanceof Ack) {\n                    _args = new Object[lastIndex];\n                    for (int i = 0; i < lastIndex; i++) {\n                        _args[i] = args[i];\n                    }\n                    ack = (Ack) args[lastIndex];\n                } else {\n                    _args = args;\n                    ack = null;\n                }\n\n                emit(event, _args, ack);\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Emits an event with an acknowledge.\n     *\n     * @param event an event name\n     * @param args data to send.\n     * @param ack the acknowledgement to be called\n     * @return a reference to this object.\n     */\n    public Emitter emit(final String event, final Object[] args, final Ack ack) {\n        EventThread.exec(new Runnable() {\n            @Override\n            public void run() {\n                JSONArray jsonArgs = new JSONArray();\n                jsonArgs.put(event);\n\n                if (args != null) {\n                    for (Object arg : args) {\n                        jsonArgs.put(arg);\n                    }\n                }\n\n                Packet<JSONArray> packet = new Packet<>(Parser.EVENT, jsonArgs);\n\n                if (ack != null) {\n                    final int ackId = Socket.this.ids;\n\n                    logger.fine(String.format(\"emitting packet with ack id %d\", ackId));\n\n                    if (ack instanceof AckWithTimeout) {\n                        final AckWithTimeout ackWithTimeout = (AckWithTimeout) ack;\n                        ackWithTimeout.schedule(new TimerTask() {\n                            @Override\n                            public void run() {\n                                // remove the ack from the map (to prevent an actual acknowledgement)\n                                acks.remove(ackId);\n\n                                // remove the packet from the buffer (if applicable)\n                                Iterator<Packet<JSONArray>> iterator = sendBuffer.iterator();\n                                while (iterator.hasNext()) {\n                                    if (iterator.next().id == ackId) {\n                                        iterator.remove();\n                                    }\n                                }\n\n                                ackWithTimeout.onTimeout();\n                            }\n                        });\n                    }\n\n                    Socket.this.acks.put(ackId, ack);\n                    packet.id = ids++;\n                }\n\n                if (Socket.this.connected) {\n                    Socket.this.packet(packet);\n                } else {\n                    Socket.this.sendBuffer.add(packet);\n                }\n            }\n        });\n        return this;\n    }\n\n    private void packet(Packet packet) {\n        if (packet.type == Parser.EVENT) {\n            if (!onAnyOutgoingListeners.isEmpty()) {\n                Object[] argsAsArray = toArray((JSONArray) packet.data);\n                for (Listener listener : onAnyOutgoingListeners) {\n                    listener.call(argsAsArray);\n                }\n            }\n        }\n        packet.nsp = this.nsp;\n        this.io.packet(packet);\n    }\n\n    private void onopen() {\n        logger.fine(\"transport is open - connecting\");\n\n        if (this.auth != null) {\n            this.packet(new Packet<>(Parser.CONNECT, new JSONObject(this.auth)));\n        } else {\n            this.packet(new Packet<>(Parser.CONNECT));\n        }\n    }\n\n    private void onclose(String reason) {\n        if (logger.isLoggable(Level.FINE)) {\n            logger.fine(String.format(\"close (%s)\", reason));\n        }\n        this.connected = false;\n        this.id = null;\n        super.emit(EVENT_DISCONNECT, reason);\n    }\n\n    private void onpacket(Packet<?> packet) {\n        if (!this.nsp.equals(packet.nsp)) return;\n\n        switch (packet.type) {\n            case Parser.CONNECT: {\n                if (packet.data instanceof JSONObject && ((JSONObject) packet.data).has(\"sid\")) {\n                    try {\n                        this.onconnect(((JSONObject) packet.data).getString(\"sid\"));\n                        return;\n                    } catch (JSONException e) {}\n                } else {\n                    super.emit(EVENT_CONNECT_ERROR, new SocketIOException(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, which is not possible\"));\n                }\n                break;\n            }\n\n            case Parser.EVENT: {\n                @SuppressWarnings(\"unchecked\")\n                Packet<JSONArray> p = (Packet<JSONArray>) packet;\n                this.onevent(p);\n                break;\n            }\n\n            case Parser.BINARY_EVENT: {\n                @SuppressWarnings(\"unchecked\")\n                Packet<JSONArray> p = (Packet<JSONArray>) packet;\n                this.onevent(p);\n                break;\n            }\n\n            case Parser.ACK: {\n                @SuppressWarnings(\"unchecked\")\n                Packet<JSONArray> p = (Packet<JSONArray>) packet;\n                this.onack(p);\n                break;\n            }\n\n            case Parser.BINARY_ACK: {\n                @SuppressWarnings(\"unchecked\")\n                Packet<JSONArray> p = (Packet<JSONArray>) packet;\n                this.onack(p);\n                break;\n            }\n\n            case Parser.DISCONNECT:\n                this.ondisconnect();\n                break;\n\n            case Parser.CONNECT_ERROR:\n                this.destroy();\n                super.emit(EVENT_CONNECT_ERROR, packet.data);\n                break;\n        }\n    }\n\n    private void onevent(Packet<JSONArray> packet) {\n        List<Object> args = new ArrayList<>(Arrays.asList(toArray(packet.data)));\n        if (logger.isLoggable(Level.FINE)) {\n            logger.fine(String.format(\"emitting event %s\", args));\n        }\n\n        if (packet.id >= 0) {\n            logger.fine(\"attaching ack callback to event\");\n            args.add(this.ack(packet.id));\n        }\n\n        if (this.connected) {\n            if (args.isEmpty()) return;\n            if (!this.onAnyIncomingListeners.isEmpty()) {\n                Object[] argsAsArray = args.toArray();\n                for (Listener listener : this.onAnyIncomingListeners) {\n                    listener.call(argsAsArray);\n                }\n            }\n            String event = args.remove(0).toString();\n            super.emit(event, args.toArray());\n        } else {\n            this.receiveBuffer.add(args);\n        }\n    }\n\n    private Ack ack(final int id) {\n        final Socket self = this;\n        final boolean[] sent = new boolean[] {false};\n        return new Ack() {\n            @Override\n            public void call(final Object... args) {\n                EventThread.exec(new Runnable() {\n                    @Override\n                    public void run() {\n                        if (sent[0]) return;\n                        sent[0] = true;\n                        if (logger.isLoggable(Level.FINE)) {\n                            logger.fine(String.format(\"sending ack %s\", args.length != 0 ? args : null));\n                        }\n\n                        JSONArray jsonArgs = new JSONArray();\n                        for (Object arg : args) {\n                            jsonArgs.put(arg);\n                        }\n\n                        Packet<JSONArray> packet = new Packet<>(Parser.ACK, jsonArgs);\n                        packet.id = id;\n                        self.packet(packet);\n                    }\n                });\n            }\n        };\n    }\n\n    private void onack(Packet<JSONArray> packet) {\n        Ack fn = this.acks.remove(packet.id);\n        if (fn != null) {\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(String.format(\"calling ack %s with %s\", packet.id, packet.data));\n            }\n            fn.call(toArray(packet.data));\n        } else {\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(String.format(\"bad ack %s\", packet.id));\n            }\n        }\n    }\n\n    private void onconnect(String id) {\n        this.connected = true;\n        this.id = id;\n        this.emitBuffered();\n        super.emit(EVENT_CONNECT);\n    }\n\n    private void emitBuffered() {\n        List<Object> data;\n        while ((data = this.receiveBuffer.poll()) != null) {\n            String event = (String)data.get(0);\n            super.emit(event, data.toArray());\n        }\n        this.receiveBuffer.clear();\n\n        Packet<JSONArray> packet;\n        while ((packet = this.sendBuffer.poll()) != null) {\n            this.packet(packet);\n        }\n        this.sendBuffer.clear();\n    }\n\n    private void ondisconnect() {\n        if (logger.isLoggable(Level.FINE)) {\n            logger.fine(String.format(\"server disconnect (%s)\", this.nsp));\n        }\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n\n    private void destroy() {\n        if (this.subs != null) {\n            // clean subscriptions to avoid reconnection\n            for (On.Handle sub : this.subs) {\n                sub.destroy();\n            }\n            this.subs = null;\n        }\n\n        for (Ack ack : acks.values()) {\n            if (ack instanceof AckWithTimeout) {\n                ((AckWithTimeout) ack).cancelTimer();\n            }\n        }\n\n        this.io.destroy();\n    }\n\n    /**\n     * Disconnects the socket.\n     *\n     * @return a reference to this object.\n     */\n    public Socket close() {\n        EventThread.exec(new Runnable() {\n            @Override\n            public void run() {\n                if (Socket.this.connected) {\n                    if (logger.isLoggable(Level.FINE)) {\n                        logger.fine(String.format(\"performing disconnect (%s)\", Socket.this.nsp));\n                    }\n                    Socket.this.packet(new Packet(Parser.DISCONNECT));\n                }\n\n                Socket.this.destroy();\n\n                if (Socket.this.connected) {\n                    Socket.this.onclose(\"io client disconnect\");\n                }\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Disconnects the socket.\n     *\n     * @return a reference to this object.\n     */\n    public Socket disconnect() {\n        return this.close();\n    }\n\n    public Manager io() {\n        return this.io;\n    }\n\n    public boolean connected() {\n        return this.connected;\n    }\n\n    /**\n     * A property on the socket instance that is equal to the underlying engine.io socket id.\n     *\n     * The value is present once the socket has connected, is removed when the socket disconnects and is updated if the socket reconnects.\n     *\n     * @return a socket id\n     */\n    public String id() {\n        return this.id;\n    }\n\n    private static Object[] toArray(JSONArray array) {\n        int length = array.length();\n        Object[] data = new Object[length];\n        for (int i = 0; i < length; i++) {\n            Object v;\n            try {\n                v = array.get(i);\n            } catch (JSONException e) {\n                logger.log(Level.WARNING, \"An error occured while retrieving data from JSONArray\", e);\n                v = null;\n            }\n            data[i] = JSONObject.NULL.equals(v) ? null : v;\n        }\n        return data;\n    }\n\n    public Socket onAnyIncoming(Listener fn) {\n        this.onAnyIncomingListeners.add(fn);\n        return this;\n    }\n\n    public Socket offAnyIncoming() {\n        this.onAnyIncomingListeners.clear();\n        return this;\n    }\n\n    public Socket offAnyIncoming(Listener fn) {\n        Iterator<Listener> it = this.onAnyIncomingListeners.iterator();\n        while (it.hasNext()) {\n            Listener listener = it.next();\n            if (listener == fn) {\n                it.remove();\n                break;\n            }\n        }\n        return this;\n    }\n\n    public Socket onAnyOutgoing(Listener fn) {\n        this.onAnyOutgoingListeners.add(fn);\n        return this;\n    }\n\n    public Socket offAnyOutgoing() {\n        this.onAnyOutgoingListeners.clear();\n        return this;\n    }\n\n    public Socket offAnyOutgoing(Listener fn) {\n        Iterator<Listener> it = this.onAnyOutgoingListeners.iterator();\n        while (it.hasNext()) {\n            Listener listener = it.next();\n            if (listener == fn) {\n                it.remove();\n                break;\n            }\n        }\n        return this;\n    }\n}\n\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "SocketIOException.java",
                                              "content": "package io.socket.client;\n\npublic class SocketIOException extends Exception {\n\n    public SocketIOException() {\n        super();\n    }\n\n    public SocketIOException(String message) {\n        super(message);\n    }\n\n    public SocketIOException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public SocketIOException(Throwable cause) {\n        super(cause);\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "SocketOptionBuilder.java",
                                              "content": "package io.socket.client;\n\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * Convenient builder class that helps creating\n * {@link io.socket.client.IO.Options Client Option} object as builder pattern.\n * Finally, you can get option object with call {@link #build()} method.\n *\n * @author junbong\n */\npublic class SocketOptionBuilder {\n    /**\n     * Construct new builder with default preferences.\n     *\n     * @return new builder object\n     * @see SocketOptionBuilder#builder(IO.Options)\n     */\n    public static SocketOptionBuilder builder() {\n        return new SocketOptionBuilder();\n    }\n\n\n    /**\n     * Construct this builder from specified option object.\n     * The option that returned from {@link #build()} method\n     * is not equals with given option.\n     * In other words, builder creates new option object\n     * and copy all preferences from given option.\n     *\n     * @param options option object which to copy preferences\n     * @return new builder object\n     */\n    public static SocketOptionBuilder builder(IO.Options options) {\n        return new SocketOptionBuilder(options);\n    }\n\n\n    private final IO.Options options = new IO.Options();\n\n\n    /**\n     * Construct new builder with default preferences.\n     */\n    protected SocketOptionBuilder() {\n        this(null);\n    }\n\n\n    /**\n     * Construct this builder from specified option object.\n     * The option that returned from {@link #build()} method\n     * is not equals with given option.\n     * In other words, builder creates new option object\n     * and copy all preferences from given option.\n     *\n     * @param options option object which to copy preferences. Null-ok.\n     */\n    protected SocketOptionBuilder(IO.Options options) {\n        if (options != null) {\n            this.setForceNew(options.forceNew)\n                .setMultiplex(options.multiplex)\n                .setReconnection(options.reconnection)\n                .setReconnectionAttempts(options.reconnectionAttempts)\n                .setReconnectionDelay(options.reconnectionDelay)\n                .setReconnectionDelayMax(options.reconnectionDelayMax)\n                .setRandomizationFactor(options.randomizationFactor)\n                .setTimeout(options.timeout)\n                .setTransports(options.transports)\n                .setUpgrade(options.upgrade)\n                .setRememberUpgrade(options.rememberUpgrade)\n                .setHost(options.host)\n                .setHostname(options.hostname)\n                .setPort(options.port)\n                .setPolicyPort(options.policyPort)\n                .setSecure(options.secure)\n                .setPath(options.path)\n                .setQuery(options.query)\n                .setAuth(options.auth)\n                .setExtraHeaders(options.extraHeaders);\n        }\n    }\n\n    public SocketOptionBuilder setForceNew(boolean forceNew) {\n        this.options.forceNew = forceNew;\n        return this;\n    }\n\n    public SocketOptionBuilder setMultiplex(boolean multiplex) {\n        this.options.multiplex = multiplex;\n        return this;\n    }\n\n    public SocketOptionBuilder setReconnection(boolean reconnection) {\n        this.options.reconnection = reconnection;\n        return this;\n    }\n\n    public SocketOptionBuilder setReconnectionAttempts(int reconnectionAttempts) {\n        this.options.reconnectionAttempts = reconnectionAttempts;\n        return this;\n    }\n\n    public SocketOptionBuilder setReconnectionDelay(long reconnectionDelay) {\n        this.options.reconnectionDelay = reconnectionDelay;\n        return this;\n    }\n\n    public SocketOptionBuilder setReconnectionDelayMax(long reconnectionDelayMax) {\n        this.options.reconnectionDelayMax = reconnectionDelayMax;\n        return this;\n    }\n\n\n    public SocketOptionBuilder setRandomizationFactor(double randomizationFactor) {\n        this.options.randomizationFactor = randomizationFactor;\n        return this;\n    }\n\n    public SocketOptionBuilder setTimeout(long timeout) {\n        this.options.timeout = timeout;\n        return this;\n    }\n\n    public SocketOptionBuilder setTransports(String[] transports) {\n        this.options.transports = transports;\n        return this;\n    }\n\n    public SocketOptionBuilder setUpgrade(boolean upgrade) {\n        this.options.upgrade = upgrade;\n        return this;\n    }\n\n    public SocketOptionBuilder setRememberUpgrade(boolean rememberUpgrade) {\n        this.options.rememberUpgrade = rememberUpgrade;\n        return this;\n    }\n\n    public SocketOptionBuilder setHost(String host) {\n        this.options.host = host;\n        return this;\n    }\n\n    public SocketOptionBuilder setHostname(String hostname) {\n        this.options.hostname = hostname;\n        return this;\n    }\n\n    public SocketOptionBuilder setPort(int port) {\n        this.options.port = port;\n        return this;\n    }\n\n    public SocketOptionBuilder setPolicyPort(int policyPort) {\n        this.options.policyPort = policyPort;\n        return this;\n    }\n\n    public SocketOptionBuilder setQuery(String query) {\n        this.options.query = query;\n        return this;\n    }\n\n    public SocketOptionBuilder setSecure(boolean secure) {\n        this.options.secure = secure;\n        return this;\n    }\n\n    public SocketOptionBuilder setPath(String path) {\n        this.options.path = path;\n        return this;\n    }\n\n    public SocketOptionBuilder setAuth(Map<String, String> auth) {\n        this.options.auth = auth;\n        return this;\n    }\n\n    public SocketOptionBuilder setExtraHeaders(Map<String, List<String>> extraHeaders) {\n        this.options.extraHeaders = extraHeaders;\n        return this;\n    }\n\n    /**\n     * Finally retrieve {@link io.socket.client.IO.Options} object\n     * from this builder.\n     *\n     * @return option that built from this builder\n     */\n    public IO.Options build() {\n        return this.options;\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "Url.java",
                                              "content": "package io.socket.client;\n\nimport java.net.URI;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Url {\n\n    /**\n     * Expected format: \"[id:password@]host[:port]\"\n     */\n    private static Pattern PATTERN_AUTHORITY = Pattern.compile(\"^(.*@)?([^:]+)(:\\\\d+)?$\");\n\n    private Url() {}\n\n    static class ParsedURI {\n        public final URI uri;\n        public final String id;\n\n        public ParsedURI(URI uri, String id) {\n            this.uri = uri;\n            this.id = id;\n        }\n    }\n\n    public static ParsedURI parse(URI uri) {\n        String protocol = uri.getScheme();\n        if (protocol == null || !protocol.matches(\"^https?|wss?$\")) {\n            protocol = \"https\";\n        }\n\n        int port = uri.getPort();\n        if (port == -1) {\n            if (\"http\".equals(protocol) || \"ws\".equals(protocol)) {\n                port = 80;\n            } else if (\"https\".equals(protocol) || \"wss\".equals(protocol)) {\n                port = 443;\n            }\n        }\n\n        String path = uri.getRawPath();\n        if (path == null || path.length() == 0) {\n            path = \"/\";\n        }\n\n        String userInfo = uri.getRawUserInfo();\n        String query = uri.getRawQuery();\n        String fragment = uri.getRawFragment();\n        String _host = uri.getHost();\n        if (_host == null) {\n            // might happen on some of Samsung Devices such as S4.\n            _host = extractHostFromAuthorityPart(uri.getRawAuthority());\n        }\n        URI completeUri = URI.create(protocol + \"://\"\n                + (userInfo != null ? userInfo + \"@\" : \"\")\n                + _host\n                + (port != -1 ? \":\" + port : \"\")\n                + path\n                + (query != null ? \"?\" + query : \"\")\n                + (fragment != null ? \"#\" + fragment : \"\"));\n        String id = protocol + \"://\" + _host + \":\" + port;\n\n        return new ParsedURI(completeUri, id);\n    }\n\n\n    private static String extractHostFromAuthorityPart(String authority)\n    {\n        if (authority == null) {\n            throw new RuntimeException(\"unable to parse the host from the authority\");\n        }\n\n        Matcher matcher = PATTERN_AUTHORITY.matcher(authority);\n\n        // If the authority part does not match the expected format.\n        if (!matcher.matches()) {\n            throw new RuntimeException(\"unable to parse the host from the authority\");\n        }\n\n        // Return the host part.\n        return matcher.group(2);\n    }\n\n}\n"
                                            }
                                          }
                                        ]
                                      }
                                    },
                                    {
                                      "directory": {
                                        "path": "hasbinary",
                                        "content": [
                                          {
                                            "javaFile": {
                                              "path": "HasBinary.java",
                                              "content": "package io.socket.hasbinary;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport java.util.Iterator;\n\npublic class HasBinary {\n\t\n    private static final Logger logger = Logger.getLogger(HasBinary.class.getName());\n\t\n    private HasBinary() {}\n\n    public static boolean hasBinary(Object data) {\n        return _hasBinary(data);\n    }\n\n    private static boolean _hasBinary(Object obj) {\n        if (obj == null) return false;\n\n        if (obj instanceof byte[]) {\n            return true;\n        }\n\n        if (obj instanceof JSONArray) {\n            JSONArray _obj = (JSONArray)obj;\n            int length = _obj.length();\n            for (int i = 0; i < length; i++) {\n                Object v;\n                try {\n                    v = _obj.isNull(i) ? null : _obj.get(i);\n                } catch (JSONException e) {\n                    logger.log(Level.WARNING, \"An error occured while retrieving data from JSONArray\", e);\n                    return false;\n                }\n                if (_hasBinary(v)) {\n                    return true;\n                }\n            }\n        } else if (obj instanceof JSONObject) {\n            JSONObject _obj = (JSONObject)obj;\n            Iterator keys = _obj.keys();\n            while (keys.hasNext()) {\n                String key = (String)keys.next();\n                Object v;\n                try {\n                    v = _obj.get(key);\n                } catch (JSONException e) {\n                    logger.log(Level.WARNING, \"An error occured while retrieving data from JSONObject\", e);\n                    return false;       \n                }\n                if (_hasBinary(v)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n"
                                            }
                                          }
                                        ]
                                      }
                                    },
                                    {
                                      "directory": {
                                        "path": "parser",
                                        "content": [
                                          {
                                            "javaFile": {
                                              "path": "Binary.java",
                                              "content": "package io.socket.parser;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class Binary {\n\n    private static final String KEY_PLACEHOLDER = \"_placeholder\";\n\n    private static final String KEY_NUM = \"num\";\n    \n    private static final Logger logger = Logger.getLogger(Binary.class.getName());\n\n    @SuppressWarnings(\"unchecked\")\n    public static DeconstructedPacket deconstructPacket(Packet packet) {\n        List<byte[]> buffers = new ArrayList<>();\n\n        packet.data = _deconstructPacket(packet.data, buffers);\n        packet.attachments = buffers.size();\n\n        DeconstructedPacket result = new DeconstructedPacket();\n        result.packet = packet;\n        result.buffers = buffers.toArray(new byte[buffers.size()][]);\n        return result;\n    }\n\n    private static Object _deconstructPacket(Object data, List<byte[]> buffers) {\n        if (data == null) return null;\n\n        if (data instanceof byte[]) {\n            JSONObject placeholder = new JSONObject();\n            try {\n                placeholder.put(KEY_PLACEHOLDER, true);\n                placeholder.put(KEY_NUM, buffers.size());\n            } catch (JSONException e) {\n                logger.log(Level.WARNING, \"An error occured while putting data to JSONObject\", e);\n                return null;\n            }\n            buffers.add((byte[])data);\n            return placeholder;\n        } else if (data instanceof JSONArray) {\n            JSONArray newData = new JSONArray();\n            JSONArray _data = (JSONArray)data;\n            int len = _data.length();\n            for (int i = 0; i < len; i ++) {\n                try {\n                    newData.put(i, _deconstructPacket(_data.get(i), buffers));\n                } catch (JSONException e) {\n                    logger.log(Level.WARNING, \"An error occured while putting packet data to JSONObject\", e);\n                    return null;\n                }\n            }\n            return newData;\n        } else if (data instanceof JSONObject) {\n            JSONObject newData = new JSONObject();\n            JSONObject _data = (JSONObject)data;\n            Iterator<?> iterator = _data.keys();\n            while (iterator.hasNext()) {\n                String key = (String)iterator.next();\n                try {\n                    newData.put(key, _deconstructPacket(_data.get(key), buffers));\n                } catch (JSONException e) {\n                    logger.log(Level.WARNING, \"An error occured while putting data to JSONObject\", e);\n                    return null;\n                }\n            }\n            return newData;\n        }\n        return data;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static Packet reconstructPacket(Packet packet, byte[][] buffers) {\n        packet.data = _reconstructPacket(packet.data, buffers);\n        packet.attachments = -1;\n       return packet;\n    }\n\n    private static Object _reconstructPacket(Object data, byte[][] buffers) {\n        if (data instanceof JSONArray) {\n            JSONArray _data = (JSONArray)data;\n            int len = _data.length();\n            for (int i = 0; i < len; i ++) {\n                try {\n                    _data.put(i, _reconstructPacket(_data.get(i), buffers));\n                } catch (JSONException e) {\n                    logger.log(Level.WARNING, \"An error occured while putting packet data to JSONObject\", e);\n                    return null;\n                }\n            }\n            return _data;\n        } else if (data instanceof JSONObject) {\n            JSONObject _data = (JSONObject)data;\n            if (_data.optBoolean(KEY_PLACEHOLDER)) {\n                int num = _data.optInt(KEY_NUM, -1);\n                return num >= 0 && num < buffers.length ? buffers[num] : null;\n            }\n            Iterator<?> iterator = _data.keys();\n            while (iterator.hasNext()) {\n                String key = (String)iterator.next();\n                try {\n                    _data.put(key, _reconstructPacket(_data.get(key), buffers));\n                } catch (JSONException e) {\n                    logger.log(Level.WARNING, \"An error occured while putting data to JSONObject\", e);\n                    return null;\n                }\n            }\n            return _data;\n        }\n        return data;\n    }\n\n    public static class DeconstructedPacket {\n\n        public Packet packet;\n        public byte[][] buffers;\n    }\n}\n\n\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "DecodingException.java",
                                              "content": "package io.socket.parser;\n\npublic class DecodingException extends RuntimeException {\n    public DecodingException(String message) {\n        super(message);\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "IOParser.java",
                                              "content": "package io.socket.parser;\n\nimport io.socket.hasbinary.HasBinary;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.json.JSONTokener;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nfinal public class IOParser implements Parser {\n\n    private static final Logger logger = Logger.getLogger(IOParser.class.getName());\n\n    private IOParser() {}\n\n    final public static class Encoder implements Parser.Encoder {\n\n        public Encoder() {}\n\n        @Override\n        public void encode(Packet obj, Callback callback) {\n            if ((obj.type == EVENT || obj.type == ACK) && HasBinary.hasBinary(obj.data)) {\n                obj.type = obj.type == EVENT ? BINARY_EVENT : BINARY_ACK;\n            }\n\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(String.format(\"encoding packet %s\", obj));\n            }\n\n            if (BINARY_EVENT == obj.type || BINARY_ACK == obj.type) {\n                encodeAsBinary(obj, callback);\n            } else {\n                String encoding = encodeAsString(obj);\n                callback.call(new String[] {encoding});\n            }\n        }\n\n        private String encodeAsString(Packet obj) {\n            StringBuilder str = new StringBuilder(\"\" + obj.type);\n\n            if (BINARY_EVENT == obj.type || BINARY_ACK == obj.type) {\n                str.append(obj.attachments);\n                str.append(\"-\");\n            }\n\n            if (obj.nsp != null && obj.nsp.length() != 0 && !\"/\".equals(obj.nsp)) {\n                str.append(obj.nsp);\n                str.append(\",\");\n            }\n\n            if (obj.id >= 0) {\n                str.append(obj.id);\n            }\n\n            if (obj.data != null) {\n                str.append(obj.data);\n            }\n\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(String.format(\"encoded %s as %s\", obj, str));\n            }\n            return str.toString();\n        }\n\n        private void encodeAsBinary(Packet obj, Callback callback) {\n            Binary.DeconstructedPacket deconstruction = Binary.deconstructPacket(obj);\n            String pack = encodeAsString(deconstruction.packet);\n            List<Object> buffers = new ArrayList<Object>(Arrays.asList(deconstruction.buffers));\n\n            buffers.add(0, pack);\n            callback.call(buffers.toArray());\n        }\n    }\n\n    final public static class Decoder implements Parser.Decoder {\n\n        /*package*/ BinaryReconstructor reconstructor;\n\n        private Decoder.Callback onDecodedCallback;\n\n        public Decoder() {\n            this.reconstructor = null;\n        }\n\n        @Override\n        public void add(String obj) {\n            Packet packet = decodeString(obj);\n            if (BINARY_EVENT == packet.type || BINARY_ACK == packet.type) {\n                this.reconstructor = new BinaryReconstructor(packet);\n\n                if (this.reconstructor.reconPack.attachments == 0) {\n                    if (this.onDecodedCallback != null) {\n                        this.onDecodedCallback.call(packet);\n                    }\n                }\n            } else {\n                if (this.onDecodedCallback != null) {\n                    this.onDecodedCallback.call(packet);\n                }\n            }\n        }\n\n        @Override\n        public void add(byte[] obj) {\n            if (this.reconstructor == null) {\n                throw new RuntimeException(\"got binary data when not reconstructing a packet\");\n            } else {\n                Packet packet = this.reconstructor.takeBinaryData(obj);\n                if (packet != null) {\n                    this.reconstructor = null;\n                    if (this.onDecodedCallback != null) {\n                        this.onDecodedCallback.call(packet);\n                    }\n                }\n            }\n        }\n\n        private static Packet decodeString(String str) {\n            int i = 0;\n            int length = str.length();\n\n            Packet<Object> p = new Packet<>(Character.getNumericValue(str.charAt(0)));\n\n            if (p.type < 0 || p.type > types.length - 1) {\n                throw new DecodingException(\"unknown packet type \" + p.type);\n            }\n\n            if (BINARY_EVENT == p.type || BINARY_ACK == p.type) {\n                if (!str.contains(\"-\") || length <= i + 1) {\n                    throw new DecodingException(\"illegal attachments\");\n                }\n                StringBuilder attachments = new StringBuilder();\n                while (str.charAt(++i) != '-') {\n                    attachments.append(str.charAt(i));\n                }\n                p.attachments = Integer.parseInt(attachments.toString());\n            }\n\n            if (length > i + 1 && '/' == str.charAt(i + 1)) {\n                StringBuilder nsp = new StringBuilder();\n                while (true) {\n                    ++i;\n                    char c = str.charAt(i);\n                    if (',' == c) break;\n                    nsp.append(c);\n                    if (i + 1 == length) break;\n                }\n                p.nsp = nsp.toString();\n            } else {\n                p.nsp = \"/\";\n            }\n\n            if (length > i + 1){\n                Character next = str.charAt(i + 1);\n                if (Character.getNumericValue(next) > -1) {\n                    StringBuilder id = new StringBuilder();\n                    while (true) {\n                        ++i;\n                        char c = str.charAt(i);\n                        if (Character.getNumericValue(c) < 0) {\n                            --i;\n                            break;\n                        }\n                        id.append(c);\n                        if (i + 1 == length) break;\n                    }\n                    try {\n                        p.id = Integer.parseInt(id.toString());\n                    } catch (NumberFormatException e){\n                        throw new DecodingException(\"invalid payload\");\n                    }\n                }\n            }\n\n            if (length > i + 1){\n                try {\n                    str.charAt(++i);\n                    p.data = new JSONTokener(str.substring(i)).nextValue();\n                } catch (JSONException e) {\n                    logger.log(Level.WARNING, \"An error occured while retrieving data from JSONTokener\", e);\n                    throw new DecodingException(\"invalid payload\");\n                }\n                if (!isPayloadValid(p.type, p.data)) {\n                    throw new DecodingException(\"invalid payload\");\n                }\n            }\n\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(String.format(\"decoded %s as %s\", str, p));\n            }\n            return p;\n        }\n\n        private static boolean isPayloadValid(int type, Object payload) {\n            switch (type) {\n                case Parser.CONNECT:\n                case Parser.CONNECT_ERROR:\n                    return payload instanceof JSONObject;\n                case Parser.DISCONNECT:\n                    return payload == null;\n                case Parser.EVENT:\n                case Parser.BINARY_EVENT:\n                    return payload instanceof JSONArray\n                            && ((JSONArray) payload).length() > 0\n                            && !((JSONArray) payload).isNull(0);\n                case Parser.ACK:\n                case Parser.BINARY_ACK:\n                    return payload instanceof JSONArray;\n                default:\n                    return false;\n            }\n        }\n\n        @Override\n        public void destroy() {\n            if (this.reconstructor != null) {\n                this.reconstructor.finishReconstruction();\n            }\n            this.onDecodedCallback = null;\n        }\n\n        @Override\n        public void onDecoded (Callback callback) {\n            this.onDecodedCallback = callback;\n        }\n    }\n\n\n    /*package*/ static class BinaryReconstructor {\n\n        public Packet reconPack;\n\n        /*package*/ List<byte[]> buffers;\n\n        BinaryReconstructor(Packet packet) {\n            this.reconPack = packet;\n            this.buffers = new ArrayList<>();\n        }\n\n        public Packet takeBinaryData(byte[] binData) {\n            this.buffers.add(binData);\n            if (this.buffers.size() == this.reconPack.attachments) {\n                Packet packet = Binary.reconstructPacket(this.reconPack,\n                        this.buffers.toArray(new byte[this.buffers.size()][]));\n                this.finishReconstruction();\n                return packet;\n            }\n            return null;\n        }\n\n        public void finishReconstruction () {\n            this.reconPack = null;\n            this.buffers = new ArrayList<>();\n        }\n    }\n}\n\n\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "Packet.java",
                                              "content": "package io.socket.parser;\n\n\npublic class Packet<T> {\n\n    public int type = -1;\n    public int id = -1;\n    public String nsp;\n    public T data;\n    public int attachments;\n\n    public Packet() {}\n\n    public Packet(int type) {\n        this.type = type;\n    }\n\n    public Packet(int type, T data) {\n        this.type = type;\n        this.data = data;\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "Parser.java",
                                              "content": "package io.socket.parser;\n\npublic interface Parser {\n\n    /**\n     * Packet type `connect`.\n     */\n    int CONNECT = 0;\n\n    /**\n     * Packet type `disconnect`.\n     */\n    int DISCONNECT = 1;\n\n    /**\n     * Packet type `event`.\n     */\n    int EVENT = 2;\n\n    /**\n     * Packet type `ack`.\n     */\n    int ACK = 3;\n\n    /**\n     * Packet type `error`.\n     */\n    int CONNECT_ERROR = 4;\n\n    /**\n     * Packet type `binary event`.\n     */\n    int BINARY_EVENT = 5;\n\n    /**\n     * Packet type `binary ack`.\n     */\n    int BINARY_ACK = 6;\n\n    int protocol = 5;\n\n    /**\n     * Packet types.\n     */\n    String[] types = new String[] {\n        \"CONNECT\",\n        \"DISCONNECT\",\n        \"EVENT\",\n        \"ACK\",\n        \"ERROR\",\n        \"BINARY_EVENT\",\n        \"BINARY_ACK\"\n    };\n\n    interface Encoder {\n\n        void encode(Packet obj, Callback callback);\n\n        interface Callback {\n\n            void call(Object[] data);\n        }\n    }\n\n    interface Decoder {\n\n        void add(String obj);\n\n        void add(byte[] obj);\n\n        void destroy();\n\n        void onDecoded(Callback callback);\n\n        interface Callback {\n\n            void call(Packet packet);\n        }\n    }\n}\n\n\n"
                                            }
                                          }
                                        ]
                                      }
                                    }
                                  ]
                                }
                              }
                            ]
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            },
            {
              "directory": {
                "path": "test",
                "content": [
                  {
                    "directory": {
                      "path": "java",
                      "content": [
                        {
                          "directory": {
                            "path": "io",
                            "content": [
                              {
                                "directory": {
                                  "path": "socket",
                                  "content": [
                                    {
                                      "javaFile": {
                                        "path": "Fiddle.java",
                                        "content": "package io.socket;\n\nimport io.socket.client.IO;\nimport io.socket.client.Socket;\nimport io.socket.emitter.Emitter;\n\nimport java.net.URI;\n\npublic class Fiddle {\n\n    public static void main(String[] argz) throws Exception {\n        IO.Options options = new IO.Options();\n\n        Socket socket = IO.socket(URI.create(\"http://localhost:3000\"), options);\n\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                System.out.println(\"connect\");\n            }\n        });\n\n        socket.on(Socket.EVENT_CONNECT_ERROR, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                System.out.println(\"connect_error: \" + args[0]);\n            }\n        });\n\n        socket.on(Socket.EVENT_DISCONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                System.out.println(\"disconnect due to: \" + args[0]);\n            }\n        });\n\n        socket.connect();\n    }\n}\n"
                                      }
                                    },
                                    {
                                      "directory": {
                                        "path": "backo",
                                        "content": [
                                          {
                                            "javaFile": {
                                              "path": "BackoffTest.java",
                                              "content": "package io.socket.backo;\n\nimport org.junit.Test;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport static org.junit.Assert.assertTrue;\n\npublic class BackoffTest {\n\n    @Test\n    public void durationShouldIncreaseTheBackoff() {\n        Backoff b = new Backoff();\n\n        assertTrue(100 == b.duration());\n        assertTrue(200 == b.duration());\n        assertTrue(400 == b.duration());\n        assertTrue(800 == b.duration());\n\n        b.reset();\n        assertTrue(100 == b.duration());\n        assertTrue(200 == b.duration());\n    }\n\n    @Test\n    public void durationOverflow() {\n        for (int i = 0; i < 10; i++) {\n            Backoff b = new Backoff();\n            b.setMin(100);\n            b.setMax(10000);\n            b.setJitter(0.5);\n\n            // repeats to make it overflow (a long can have 2 ** 63 - 1)\n            for (int j = 0; j < 100; j++) {\n                BigInteger ms = BigInteger.valueOf(100).multiply(BigInteger.valueOf(2).pow(j));\n                BigInteger deviation = new BigDecimal(ms).multiply(BigDecimal.valueOf(0.5)).toBigInteger();\n                BigInteger duration = BigInteger.valueOf(b.duration());\n\n                BigInteger min = ms.subtract(deviation).min(BigInteger.valueOf(10000));\n                BigInteger max = ms.add(deviation).min(BigInteger.valueOf(10001));\n                assertTrue(min + \" <= \" + duration + \" < \" + max,\n                        min.compareTo(duration) <= 0 && max.compareTo(duration) == 1);\n            }\n        }\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void ensureJitterIsValid() {\n        Backoff b = new Backoff();\n        b.setJitter(2);\n    }\n}\n"
                                            }
                                          }
                                        ]
                                      }
                                    },
                                    {
                                      "directory": {
                                        "path": "client",
                                        "content": [
                                          {
                                            "javaFile": {
                                              "path": "Connection.java",
                                              "content": "package io.socket.client;\n\nimport org.junit.After;\nimport org.junit.Before;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URI;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.*;\nimport java.util.logging.Logger;\n\npublic abstract class Connection {\n\n    private static final Logger logger = Logger.getLogger(Connection.class.getName());\n\n    final static int TIMEOUT = 7000;\n    final static int PORT = 3000;\n\n    private Process serverProcess;\n    private ExecutorService serverService;\n    private Future serverOutput;\n    private Future serverError;\n\n    @Before\n    public void startServer() throws IOException, InterruptedException {\n        logger.fine(\"Starting server ...\");\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        serverProcess = Runtime.getRuntime().exec(\n                String.format(\"node src/test/resources/server.js %s\", nsp()), createEnv());\n        serverService = Executors.newCachedThreadPool();\n        serverOutput = serverService.submit(new Runnable() {\n            @Override\n            public void run() {\n                BufferedReader reader = new BufferedReader(\n                        new InputStreamReader(serverProcess.getInputStream()));\n                String line;\n                try {\n                    line = reader.readLine();\n                    latch.countDown();\n                    do {\n                        logger.fine(\"SERVER OUT: \" + line);\n                    } while ((line = reader.readLine()) != null);\n                } catch (IOException e) {\n                    logger.warning(e.getMessage());\n                }\n            }\n        });\n        serverError = serverService.submit(new Runnable() {\n            @Override\n            public void run() {\n                BufferedReader reader = new BufferedReader(\n                        new InputStreamReader(serverProcess.getErrorStream()));\n                String line;\n                try {\n                    while ((line = reader.readLine()) != null) {\n                        logger.fine(\"SERVER ERR: \" + line);\n                    }\n                } catch (IOException e) {\n                    logger.warning(e.getMessage());\n                }\n            }\n        });\n        latch.await(3000, TimeUnit.MILLISECONDS);\n    }\n\n    @After\n    public void stopServer() throws InterruptedException {\n        logger.fine(\"Stopping server ...\");\n        serverProcess.destroy();\n        serverOutput.cancel(false);\n        serverError.cancel(false);\n        serverService.shutdown();\n        serverService.awaitTermination(3000, TimeUnit.MILLISECONDS);\n    }\n\n    Socket client() {\n        return client(createOptions());\n    }\n\n    Socket client(String path) {\n        return client(path, createOptions());\n    }\n\n    Socket client(IO.Options opts) {\n        return client(nsp(), opts);\n    }\n\n    Socket client(String path, IO.Options opts) {\n        return IO.socket(URI.create(uri() + path), opts);\n    }\n\n    URI uri() {\n        return URI.create(\"http://localhost:\" + PORT);\n    }\n\n    String nsp() {\n        return \"/\";\n    }\n\n    IO.Options createOptions() {\n        IO.Options opts = new IO.Options();\n        opts.forceNew = true;\n        return opts;\n    }\n\n    String[] createEnv() {\n        Map<String, String> env = new HashMap<>(System.getenv());\n        env.put(\"DEBUG\", \"socket.io:*\");\n        env.put(\"PORT\", String.valueOf(PORT));\n        String[] _env = new String[env.size()];\n        int i = 0;\n        for (String key : env.keySet()) {\n            _env[i] = key + \"=\" + env.get(key);\n            i++;\n        }\n        return _env;\n\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "ConnectionTest.java",
                                              "content": "package io.socket.client;\n\nimport io.socket.emitter.Emitter;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.charset.Charset;\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.CoreMatchers.not;\nimport static org.junit.Assert.assertThat;\n\n@RunWith(JUnit4.class)\npublic class ConnectionTest extends Connection {\n\n    private Socket socket;\n\n    @Test(timeout = TIMEOUT)\n    public void connectToLocalhost() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"echo\");\n                socket.on(\"echoBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(\"done\");\n                    }\n                });\n            }\n        });\n        socket.connect();\n        values.take();\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void startTwoConnectionsWithSamePath() throws InterruptedException {\n        Socket s1 = client(\"/\");\n        Socket s2 = client(\"/\");\n\n        assertThat(s1.io(), not(equalTo(s2.io())));\n        s1.close();\n        s2.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void startTwoConnectionsWithSamePathAndDifferentQuerystrings() throws InterruptedException {\n        Socket s1 = client(\"/?woot\");\n        Socket s2 = client(\"/\");\n\n        assertThat(s1.io(), not(equalTo(s2.io())));\n        s1.close();\n        s2.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void workWithAcks() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"callAck\");\n                socket.on(\"ack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        Ack fn = (Ack) args[0];\n                        JSONObject data = new JSONObject();\n                        try {\n                            data.put(\"test\", true);\n                        } catch (JSONException e) {\n                            throw new AssertionError(e);\n                        }\n                        fn.call(5, data);\n                    }\n                });\n                socket.on(\"ackBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        JSONObject data = (JSONObject)args[1];\n                        try {\n                            if ((Integer)args[0] == 5 && data.getBoolean(\"test\")) {\n                                values.offer(\"done\");\n                            }\n                        } catch (JSONException e) {\n                            throw new AssertionError(e);\n                        }\n                    }\n                });\n            }\n        });\n        socket.connect();\n        values.take();\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void receiveDateWithAck() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                try {\n                    socket.emit(\"getAckDate\", new JSONObject(\"{test: true}\"), new Ack() {\n                        @Override\n                        public void call(Object... args) {\n                            values.offer(args[0]);\n                        }\n                    });\n                } catch (JSONException e) {\n                    throw new AssertionError(e);\n                }\n            }\n        });\n        socket.connect();\n        assertThat(values.take(), instanceOf(String.class));\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void sendBinaryAck() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        final byte[] buf = \"huehue\".getBytes(Charset.forName(\"UTF-8\"));\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"callAckBinary\");\n                socket.on(\"ack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        Ack fn = (Ack) args[0];\n                        fn.call(buf);\n                    }\n                });\n\n                socket.on(\"ackBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        byte[] data = (byte[])args[0];\n                        values.offer(data);\n                    }\n                });\n            }\n        });\n        socket.connect();\n        Assert.assertArrayEquals(buf, (byte[])values.take());\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void receiveBinaryDataWithAck() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        final byte[] buf = \"huehue\".getBytes(Charset.forName(\"UTF-8\"));\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"getAckBinary\", \"\", new Ack() {\n\n                    @Override\n                    public void call(Object... args) {\n                       values.offer(args[0]);\n                    }\n                });\n            }\n        });\n        socket.connect();\n        Assert.assertArrayEquals(buf, (byte[])values.take());\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void workWithFalse() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"echo\", false);\n                socket.on(\"echoBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(args[0]);\n                    }\n                });\n            }\n        });\n        socket.connect();\n        assertThat((Boolean)values.take(), is(false));\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void receiveUTF8MultibyteCharacters() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        final String[] correct = new String[] {\n            \"てすと\",\n            \"Я Б Г Д Ж Й\",\n            \"Ä ä Ü ü ß\",\n            \"utf8 — string\",\n            \"utf8 — string\"\n        };\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.on(\"echoBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(args[0]);\n                    }\n                });\n                for (String data : correct) {\n                    socket.emit(\"echo\", data);\n                }\n            }\n        });\n        socket.connect();\n        for (String expected : correct) {\n            assertThat((String)values.take(), is(expected));\n        }\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void connectToNamespaceAfterConnectionEstablished() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        final Manager manager = new Manager(uri());\n        socket = manager.socket(\"/\");\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                final Socket foo = manager.socket(\"/foo\");\n                foo.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        foo.close();\n                        socket.close();\n                        manager.close();\n                        values.offer(\"done\");\n                    }\n                });\n                foo.open();\n            }\n        });\n        socket.open();\n        values.take();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void connectToNamespaceAfterConnectionGetsClosed() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        final Manager manager = new Manager(uri());\n        socket = manager.socket(\"/\");\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.close();\n            }\n        }).on(Socket.EVENT_DISCONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                final Socket foo = manager.socket(\"/foo\");\n                foo.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        foo.close();\n                        manager.close();\n                        values.offer(\"done\");\n                    }\n                });\n                foo.open();\n            }\n        });\n        socket.open();\n        values.take();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void reconnectByDefault() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        socket = client();\n        socket.io().on(Manager.EVENT_RECONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.close();\n                values.offer(\"done\");\n            }\n        });\n        socket.open();\n        new Timer().schedule(new TimerTask() {\n            @Override\n            public void run() {\n                socket.io().engine.close();\n            }\n        }, 500);\n        values.take();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void reconnectManually() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        socket = client();\n        socket.once(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.disconnect();\n            }\n        }).once(Socket.EVENT_DISCONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.once(Socket.EVENT_CONNECT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        socket.disconnect();\n                        values.offer(\"done\");\n                    }\n                });\n                socket.connect();\n            }\n        });\n        socket.connect();\n        values.take();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void reconnectAutomaticallyAfterReconnectingManually() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        socket = client();\n        socket.once(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.disconnect();\n            }\n        }).once(Socket.EVENT_DISCONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.io().on(Manager.EVENT_RECONNECT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        socket.disconnect();\n                        values.offer(\"done\");\n                    }\n                });\n                socket.connect();\n                new Timer().schedule(new TimerTask() {\n                    @Override\n                    public void run() {\n                        socket.io().engine.close();\n                    }\n                }, 500);\n            }\n        });\n        socket.connect();\n        values.take();\n    }\n\n    @Test(timeout = 14000)\n    public void attemptReconnectsAfterAFailedReconnect() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        IO.Options opts = createOptions();\n        opts.reconnection = true;\n        opts.timeout = 0;\n        opts.reconnectionAttempts = 2;\n        opts.reconnectionDelay = 10;\n        final Manager manager = new Manager(uri(), opts);\n        socket = manager.socket(\"/timeout\");\n        manager.once(Manager.EVENT_RECONNECT_FAILED, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                final int[] reconnects = new int[] {0};\n                Emitter.Listener reconnectCb = new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        reconnects[0]++;\n                    }\n                };\n\n                manager.on(Manager.EVENT_RECONNECT_ATTEMPT, reconnectCb);\n                manager.on(Manager.EVENT_RECONNECT_FAILED, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(reconnects[0]);\n                    }\n                });\n                socket.connect();\n            }\n        });\n        socket.connect();\n        assertThat((Integer)values.take(), is(2));\n        socket.close();\n        manager.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void reconnectDelayShouldIncreaseEveryTime() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        IO.Options opts = createOptions();\n        opts.reconnection = true;\n        opts.timeout = 0;\n        opts.reconnectionAttempts = 3;\n        opts.reconnectionDelay = 100;\n        opts.randomizationFactor = 0.2;\n        final Manager manager = new Manager(uri(), opts);\n        socket = manager.socket(\"/timeout\");\n\n        final int[] reconnects = new int[] {0};\n        final boolean[] increasingDelay = new boolean[] {true};\n        final long[] startTime = new long[] {0};\n        final long[] prevDelay = new long[] {0};\n\n        manager.on(Manager.EVENT_ERROR, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                startTime[0] = new Date().getTime();\n            }\n        });\n        manager.on(Manager.EVENT_RECONNECT_ATTEMPT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                reconnects[0]++;\n                long currentTime = new Date().getTime();\n                long delay = currentTime - startTime[0];\n                if (delay <= prevDelay[0]) {\n                    increasingDelay[0] = false;\n                }\n                prevDelay[0] = delay;\n            }\n        });\n        manager.on(Manager.EVENT_RECONNECT_FAILED, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                values.offer(true);\n            }\n        });\n\n        socket.connect();\n        values.take();\n        assertThat(reconnects[0], is(3));\n        assertThat(increasingDelay[0], is(true));\n        socket.close();\n        manager.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void notReconnectWhenForceClosed() throws URISyntaxException, InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        IO.Options opts = createOptions();\n        opts.timeout = 0;\n        opts.reconnectionDelay = 10;\n        socket = IO.socket(uri() + \"/invalid\", opts);\n        socket.io().on(Manager.EVENT_ERROR, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.io().on(Manager.EVENT_RECONNECT_ATTEMPT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(false);\n                    }\n                });\n                socket.disconnect();\n                new Timer().schedule(new TimerTask() {\n                    @Override\n                    public void run() {\n                        values.offer(true);\n                    }\n                }, 500);\n            }\n        });\n        socket.connect();\n        assertThat((Boolean)values.take(), is(true));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void stopReconnectingWhenForceClosed() throws URISyntaxException, InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        IO.Options opts = createOptions();\n        opts.timeout = 0;\n        opts.reconnectionDelay = 10;\n        socket = IO.socket(uri() + \"/invalid\", opts);\n        socket.io().once(Manager.EVENT_RECONNECT_ATTEMPT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.io().on(Manager.EVENT_RECONNECT_ATTEMPT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(false);\n                    }\n                });\n                socket.disconnect();\n                // set a timer to let reconnection possibly fire\n                new Timer().schedule(new TimerTask() {\n                    @Override\n                    public void run() {\n                        values.offer(true);\n                    }\n                }, 500);\n            }\n        });\n        socket.connect();\n        assertThat((Boolean) values.take(), is(true));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void reconnectAfterStoppingReconnection() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        IO.Options opts = createOptions();\n        opts.forceNew = true;\n        opts.timeout = 0;\n        opts.reconnectionDelay = 10;\n        socket = client(\"/invalid\", opts);\n        socket.io().once(Manager.EVENT_RECONNECT_ATTEMPT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.io().once(Manager.EVENT_RECONNECT_ATTEMPT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(\"done\");\n                    }\n                });\n                socket.disconnect();\n                socket.connect();\n            }\n        });\n        socket.connect();\n        values.take();\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void stopReconnectingOnASocketAndKeepToReconnectOnAnother() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        final Manager manager = new Manager(uri());\n        final Socket socket1 = manager.socket(\"/\");\n        final Socket socket2 = manager.socket(\"/asd\");\n\n        manager.on(Manager.EVENT_RECONNECT_ATTEMPT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket1.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(false);\n                    }\n                });\n                socket2.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        new Timer().schedule(new TimerTask() {\n                            @Override\n                            public void run() {\n                                socket2.disconnect();\n                                manager.close();\n                                values.offer(true);\n                            }\n                        }, 500);\n                    }\n                });\n                socket1.disconnect();\n            }\n        });\n\n        socket1.connect();\n        socket2.connect();\n\n        new Timer().schedule(new TimerTask() {\n            @Override\n            public void run() {\n                manager.engine.close();\n            }\n        }, 1000);\n\n        assertThat((Boolean) values.take(), is(true));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void connectWhileDisconnectingAnotherSocket() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        final Manager manager = new Manager(uri());\n        final Socket socket1 = manager.socket(\"/foo\");\n        socket1.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                final Socket socket2 = manager.socket(\"/asd\");\n                socket2.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(\"done\");\n                        socket2.disconnect();\n                    }\n                });\n                socket2.open();\n                socket1.disconnect();\n            }\n        });\n\n        socket1.open();\n        values.take();\n        manager.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void tryToReconnectTwiceAndFailWithIncorrectAddress() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        IO.Options opts = new IO.Options();\n        opts.reconnection = true;\n        opts.reconnectionAttempts = 2;\n        opts.reconnectionDelay = 10;\n        final Manager manager = new Manager(URI.create(\"http://localhost:3940\"), opts);\n        socket = manager.socket(\"/asd\");\n        final int[] reconnects = new int[] {0};\n        Emitter.Listener cb = new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                reconnects[0]++;\n            }\n        };\n\n        manager.on(Manager.EVENT_RECONNECT_ATTEMPT, cb);\n\n        manager.on(Manager.EVENT_RECONNECT_FAILED, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                values.offer(reconnects[0]);\n            }\n        });\n\n        socket.open();\n        assertThat((Integer)values.take(), is(2));\n        socket.close();\n        manager.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void tryToReconnectTwiceAndFailWithImmediateTimeout() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        IO.Options opts = new IO.Options();\n        opts.reconnection = true;\n        opts.timeout = 0;\n        opts.reconnectionAttempts = 2;\n        opts.reconnectionDelay = 10;\n        final Manager manager = new Manager(uri(), opts);\n\n        final int[] reconnects = new int[] {0};\n        Emitter.Listener reconnectCb = new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                reconnects[0]++;\n            }\n        };\n\n        manager.on(Manager.EVENT_RECONNECT_ATTEMPT, reconnectCb);\n        manager.on(Manager.EVENT_RECONNECT_FAILED, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.close();\n                manager.close();\n                values.offer(reconnects[0]);\n            }\n        });\n\n        socket = manager.socket(\"/timeout\");\n        socket.open();\n        assertThat((Integer)values.take(), is(2));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void notTryToReconnectWithIncorrectPortWhenReconnectionDisabled() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        IO.Options opts = new IO.Options();\n        opts.reconnection = false;\n        final Manager manager = new Manager(URI.create(\"http://localhost:9823\"), opts);\n        Emitter.Listener cb = new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.close();\n                throw new RuntimeException();\n            }\n        };\n        manager.on(Manager.EVENT_RECONNECT_ATTEMPT, cb);\n        manager.on(Manager.EVENT_ERROR, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                Timer timer = new Timer();\n                timer.schedule(new TimerTask() {\n                    @Override\n                    public void run() {\n                        socket.close();\n                        manager.close();\n                        values.offer(\"done\");\n                    }\n                }, 1000);\n            }\n        });\n\n        socket = manager.socket(\"/invalid\");\n        socket.open();\n        values.take();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void fireReconnectEventsOnSocket() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        Manager.Options opts = new Manager.Options();\n        opts.reconnection = true;\n        opts.timeout = 0;\n        opts.reconnectionAttempts = 2;\n        opts.reconnectionDelay = 10;\n        final Manager manager = new Manager(uri(), opts);\n        socket = manager.socket(\"/timeout_socket\");\n\n        final int[] reconnects = new int[] {0};\n        Emitter.Listener reconnectCb = new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                reconnects[0]++;\n                values.offer(args[0]);\n            }\n        };\n\n        manager.on(Manager.EVENT_RECONNECT_ATTEMPT, reconnectCb);\n        manager.on(Manager.EVENT_RECONNECT_FAILED, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.close();\n                manager.close();\n                values.offer(reconnects[0]);\n            }\n        });\n        socket.open();\n        assertThat((Integer)values.take(), is(reconnects[0]));\n        assertThat((Integer)values.take(), is(2));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void fireReconnectingWithAttemptsNumberWhenReconnectingTwice() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        Manager.Options opts = new Manager.Options();\n        opts.reconnection = true;\n        opts.timeout = 0;\n        opts.reconnectionAttempts = 2;\n        opts.reconnectionDelay = 10;\n        final Manager manager = new Manager(uri(), opts);\n        socket = manager.socket(\"/timeout_socket\");\n\n        final int[] reconnects = new int[] {0};\n        Emitter.Listener reconnectCb = new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                reconnects[0]++;\n                values.offer(args[0]);\n            }\n        };\n\n        manager.on(Manager.EVENT_RECONNECT_ATTEMPT, reconnectCb);\n        manager.on(Manager.EVENT_RECONNECT_FAILED, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.close();\n                manager.close();\n                values.offer(reconnects[0]);\n            }\n        });\n        socket.open();\n        assertThat((Integer)values.take(), is(reconnects[0]));\n        assertThat((Integer)values.take(), is(2));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void emitDateAsString() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"echo\", new Date());\n                socket.on(\"echoBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        socket.close();\n                        values.offer(args[0]);\n                    }\n                });\n            }\n        });\n        socket.connect();\n        assertThat(values.take(), instanceOf(String.class));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void emitDateInObject() throws InterruptedException, JSONException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                JSONObject data = new JSONObject();\n                try {\n                    data.put(\"date\", new Date());\n                } catch (JSONException e) {\n                    throw new AssertionError(e);\n                }\n                socket.emit(\"echo\", data);\n                socket.on(\"echoBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(args[0]);\n                    }\n                });\n            }\n        });\n        socket.connect();\n        Object data = values.take();\n        assertThat(data, instanceOf(JSONObject.class));\n        assertThat(((JSONObject)data).get(\"date\"), instanceOf(String.class));\n        socket.close();\n    }\n\n\n    @Test(timeout = TIMEOUT)\n    public void sendAndGetBinaryData() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        final byte[] buf = \"asdfasdf\".getBytes(Charset.forName(\"UTF-8\"));\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.emit(\"echo\", buf);\n                socket.on(\"echoBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(args[0]);\n                    }\n                });\n            }\n        });\n        socket.open();\n        assertThat((byte[])values.take(), is(buf));\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void sendBinaryDataMixedWithJson() throws InterruptedException, JSONException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        final byte[] buf = \"howdy\".getBytes(Charset.forName(\"UTF-8\"));\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                JSONObject data = new JSONObject();\n                try {\n                    data.put(\"hello\", \"lol\");\n                    data.put(\"message\", buf);\n                    data.put(\"goodbye\", \"gotcha\");\n                } catch (JSONException e) {\n                    throw new AssertionError(e);\n                }\n                socket.emit(\"echo\", data);\n                socket.on(\"echoBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(args[0]);\n                    }\n                });\n            }\n        });\n        socket.open();\n        JSONObject a = (JSONObject)values.take();\n        assertThat(a.getString(\"hello\"), is(\"lol\"));\n        assertThat((byte[])a.get(\"message\"), is(buf));\n        assertThat(a.getString(\"goodbye\"), is(\"gotcha\"));\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void sendEventsWithByteArraysInTheCorrectOrder() throws Exception {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        final byte[] buf = \"abuff1\".getBytes(Charset.forName(\"UTF-8\"));\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.emit(\"echo\", buf);\n                socket.emit(\"echo\", \"please arrive second\");\n\n                socket.on(\"echoBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(args[0]);\n                    }\n                });\n            }\n        });\n        socket.open();\n        assertThat((byte[])values.take(), is(buf));\n        assertThat((String)values.take(), is(\"please arrive second\"));\n        socket.close();\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "ExecutionTest.java",
                                              "content": "package io.socket.client;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.logging.Logger;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertThat;\n\n@RunWith(JUnit4.class)\npublic class ExecutionTest extends Connection {\n\n    private static final Logger logger = Logger.getLogger(ExecutionTest.class.getName());\n\n    final static int TIMEOUT = 100 * 1000;\n\n    @Test(timeout = TIMEOUT)\n    public void execConnection() throws InterruptedException, IOException {\n        exec(\"io.socket.client.executions.Connection\");\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void execConnectionFailure() throws InterruptedException, IOException {\n        exec(\"io.socket.client.executions.ConnectionFailure\");\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void execImmediateClose() throws InterruptedException, IOException {\n        exec(\"io.socket.client.executions.ImmediateClose\");\n    }\n\n    private void exec(String mainClass) throws InterruptedException, IOException {\n        Process process = Runtime.getRuntime().exec(String.format(\"mvn --quiet exec:java\" +\n                \" -Dexec.mainClass=%s -Dexec.classpathScope=test\", mainClass), createEnv());\n        BufferedReader input = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = input.readLine()) != null) {\n            logger.fine(\"EXEC OUT: \" + line);\n        }\n        process.waitFor();\n        assertThat(process.exitValue(), is(0));\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "SSLConnectionTest.java",
                                              "content": "package io.socket.client;\n\nimport io.socket.emitter.Emitter;\nimport okhttp3.OkHttpClient;\nimport org.junit.After;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.security.GeneralSecurityException;\nimport java.security.KeyStore;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\n@RunWith(JUnit4.class)\npublic class SSLConnectionTest extends Connection {\n\n    private static OkHttpClient sOkHttpClient;\n\n    private Socket socket;\n\n    static {\n        try {\n            prepareOkHttpClient();\n        } catch(GeneralSecurityException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    URI uri() {\n        return URI.create(\"https://localhost:\" + PORT);\n    }\n\n    @Override\n    IO.Options createOptions() {\n        IO.Options opts = super.createOptions();\n        opts.secure = true;\n        return opts;\n    }\n\n    @Override\n    String[] createEnv() {\n        return new String[] {\"DEBUG=socket.io:*\", \"PORT=\" + PORT, \"SSL=1\"};\n    }\n\n    private static void prepareOkHttpClient() throws GeneralSecurityException, IOException {\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        File file = new File(\"src/test/resources/keystore.jks\");\n        ks.load(new FileInputStream(file), \"password\".toCharArray());\n\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n        kmf.init(ks, \"password\".toCharArray());\n\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(ks);\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n\n        sOkHttpClient = new OkHttpClient.Builder()\n                .hostnameVerifier(new HostnameVerifier(){\n                    public boolean verify(String hostname, SSLSession sslSession) {\n                        return hostname.equals(\"localhost\");\n                    }\n                })\n                .sslSocketFactory(sslContext.getSocketFactory(),\n                        (X509TrustManager) tmf.getTrustManagers()[0])\n                .build();\n    }\n\n    @After\n    public void tearDown() {\n        IO.setDefaultOkHttpCallFactory(null);\n        IO.setDefaultOkHttpWebSocketFactory(null);\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void connect() throws Exception {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        IO.Options opts = createOptions();\n        opts.callFactory = sOkHttpClient;\n        opts.webSocketFactory = sOkHttpClient;\n        socket = client(opts);\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"echo\");\n                socket.on(\"echoBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(\"done\");\n                    }\n                });\n            }\n        });\n        socket.connect();\n        values.take();\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void defaultSSLContext() throws Exception {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n        IO.setDefaultOkHttpWebSocketFactory(sOkHttpClient);\n        IO.setDefaultOkHttpCallFactory(sOkHttpClient);\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"echo\");\n                socket.on(\"echoBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(\"done\");\n                    }\n                });\n            }\n        });\n        socket.connect();\n        values.take();\n        socket.close();\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "ServerConnectionNamespaceTest.java",
                                              "content": "package io.socket.client;\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class ServerConnectionNamespaceTest extends ServerConnectionTest {\n\n    protected String nsp() {\n        return \"/foo\";\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "ServerConnectionTest.java",
                                              "content": "package io.socket.client;\n\nimport io.socket.emitter.Emitter;\nimport io.socket.engineio.client.Transport;\nimport io.socket.engineio.client.transports.Polling;\nimport io.socket.engineio.client.transports.WebSocket;\nimport org.json.JSONObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.junit.Assert.assertThat;\n\n@RunWith(JUnit4.class)\npublic class ServerConnectionTest extends Connection {\n\n    private Socket socket;\n    private Socket socket2;\n\n    @Test(timeout = TIMEOUT)\n    public void openAndClose() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                values.offer(args);\n                socket.disconnect();\n            }\n        }).on(Socket.EVENT_DISCONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                values.offer(args);\n            }\n        });\n        socket.connect();\n\n        assertThat(((Object[])values.take()).length, is(0));\n        Object[] args = (Object[] )values.take();\n        assertThat(args.length, is(1));\n        assertThat(args[0], is(instanceOf(String.class)));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void message() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.send(\"foo\", \"bar\");\n            }\n        }).on(Socket.EVENT_MESSAGE, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                values.offer(args);\n            }\n        });\n        socket.connect();\n\n        assertThat((Object[])values.take(), is(new Object[] {\"hello client\"}));\n        assertThat((Object[])values.take(), is(new Object[] {\"foo\", \"bar\"}));\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void event() throws Exception {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        final JSONObject obj = new JSONObject();\n        obj.put(\"foo\", 1);\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"echo\", obj, null, \"bar\");\n            }\n        }).on(\"echoBack\", new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                values.offer(args);\n            }\n        });\n        socket.connect();\n\n        Object[] args = (Object[])values.take();\n        assertThat(args.length, is(3));\n        assertThat(args[0].toString(), is(obj.toString()));\n        assertThat(args[1], is(nullValue()));\n        assertThat((String)args[2], is(\"bar\"));\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void ack() throws Exception {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        final JSONObject obj = new JSONObject();\n        obj.put(\"foo\", 1);\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"ack\", new Object[] {obj, \"bar\"}, new Ack() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(args);\n                    }\n                });\n            }\n        });\n        socket.connect();\n\n        Object[] args = (Object[])values.take();\n        assertThat(args.length, is(2));\n        assertThat(args[0].toString(), is(obj.toString()));\n        assertThat((String)args[1], is(\"bar\"));\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void ackWithoutArgs() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"ack\", null, new Ack() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(args.length);\n                    }\n                });\n            }\n        });\n        socket.connect();\n\n        assertThat((Integer)values.take(), is(0));\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void ackWithoutArgsFromClient() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.on(\"ack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(args);\n                        Ack ack = (Ack)args[0];\n                        ack.call();\n                    }\n                }).on(\"ackBack\", new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(args);\n                        socket.disconnect();\n                    }\n                });\n                socket.emit(\"callAck\");\n            }\n        });\n        socket.connect();\n\n        Object[] args = (Object[])values.take();\n        assertThat(args.length, is(1));\n        assertThat(args[0], is(instanceOf(Ack.class)));\n        args = (Object[])values.take();\n        assertThat(args.length, is(0));\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void closeEngineConnection() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.io().engine.on(io.socket.engineio.client.Socket.EVENT_CLOSE, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... objects) {\n                        values.offer(\"done\");\n                    }\n                });\n                socket.disconnect();\n            }\n        });\n        socket.connect();\n        values.take();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void broadcast() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket2 = client();\n\n                socket2.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... objects) {\n                        socket2.emit(\"broadcast\", \"hi\");\n                    }\n                });\n                socket2.connect();\n            }\n        }).on(\"broadcastBack\", new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                values.offer(args);\n            }\n        });\n        socket.connect();\n\n        Object[] args = (Object[])values.take();\n        assertThat(args.length, is(1));\n        assertThat((String)args[0], is(\"hi\"));\n        socket.disconnect();\n        socket2.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void room() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"room\", \"hi\");\n            }\n        }).on(\"roomBack\", new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                values.offer(args);\n            }\n        });\n        socket.connect();\n\n        Object[] args = (Object[])values.take();\n        assertThat(args.length, is(1));\n        assertThat((String)args[0], is(\"hi\"));\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void pollingHeaders() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        IO.Options opts = createOptions();\n        opts.transports = new String[] {Polling.NAME};\n        socket = client(opts);\n        socket.io().on(Manager.EVENT_TRANSPORT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                Transport transport = (Transport)args[0];\n                transport.on(Transport.EVENT_REQUEST_HEADERS, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        @SuppressWarnings(\"unchecked\")\n                        Map<String, List<String>> headers = (Map<String, List<String>>)args[0];\n                        headers.put(\"X-SocketIO\", Arrays.asList(\"hi\"));\n                    }\n                }).on(Transport.EVENT_RESPONSE_HEADERS, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        @SuppressWarnings(\"unchecked\")\n                        Map<String, List<String>> headers = (Map<String, List<String>>)args[0];\n                        List<String> value = headers.get(\"X-SocketIO\");\n                        values.offer(value != null ? value.get(0) : \"\");\n                    }\n                });\n            }\n        });\n        socket.open();\n\n        assertThat((String)values.take(), is(\"hi\"));\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void websocketHandshakeHeaders() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        IO.Options opts = createOptions();\n        opts.transports = new String[] {WebSocket.NAME};\n        socket = client(opts);\n        socket.io().on(Manager.EVENT_TRANSPORT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                Transport transport = (Transport)args[0];\n                transport.on(Transport.EVENT_REQUEST_HEADERS, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        @SuppressWarnings(\"unchecked\")\n                        Map<String, List<String>> headers = (Map<String, List<String>>)args[0];\n                        headers.put(\"X-SocketIO\", Arrays.asList(\"hi\"));\n                    }\n                }).on(Transport.EVENT_RESPONSE_HEADERS, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        @SuppressWarnings(\"unchecked\")\n                        Map<String, List<String>> headers = (Map<String, List<String>>)args[0];\n                        List<String> value = headers.get(\"X-SocketIO\");\n                        values.offer(value != null ? value.get(0) : \"\");\n                    }\n                });\n            }\n        });\n        socket.open();\n\n        assertThat((String)values.take(), is(\"hi\"));\n        socket.close();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void disconnectFromServer() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.emit(\"requestDisconnect\");\n            }\n        }).on(Socket.EVENT_DISCONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                values.offer(\"disconnected\");\n            }\n        });\n        socket.connect();\n        assertThat((String)values.take(), is(\"disconnected\"));\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "SocketTest.java",
                                              "content": "package io.socket.client;\n\nimport io.socket.emitter.Emitter;\nimport io.socket.util.Optional;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.concurrent.*;\n\nimport static java.util.Collections.singletonMap;\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.fail;\n\n@RunWith(JUnit4.class)\npublic class SocketTest extends Connection {\n\n    private Socket socket;\n\n    @Test(timeout = TIMEOUT)\n    public void shouldHaveAnAccessibleSocketIdEqualToServerSideSocketId() throws InterruptedException {\n        final BlockingQueue<Optional> values = new LinkedBlockingQueue<>();\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                values.offer(Optional.ofNullable(socket.id()));\n            }\n        });\n        socket.connect();\n\n        @SuppressWarnings(\"unchecked\")\n        Optional<String> id = values.take();\n        assertThat(id.isPresent(), is(true));\n        assertThat(id.get(), not(socket.io().engine.id())); // distinct ID since Socket.IO v3\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldHaveAnAccessibleSocketIdEqualToServerSideSocketIdOnCustomNamespace() throws InterruptedException {\n        final BlockingQueue<Optional> values = new LinkedBlockingQueue<>();\n        socket = client(\"/foo\");\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                values.offer(Optional.ofNullable(socket.id()));\n            }\n        });\n        socket.connect();\n\n        @SuppressWarnings(\"unchecked\")\n        Optional<String> id = values.take();\n        assertThat(id.isPresent(), is(true));\n        assertThat(id.get(), is(not(socket.io().engine.id()))); // distinct ID since Socket.IO v3\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void clearsSocketIdUponDisconnection() throws InterruptedException {\n        final BlockingQueue<Optional> values = new LinkedBlockingQueue<>();\n        socket = client();\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.on(Socket.EVENT_DISCONNECT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer(Optional.ofNullable(socket.id()));\n                    }\n                });\n\n                socket.disconnect();\n            }\n        });\n        socket.connect();\n        @SuppressWarnings(\"unchecked\")\n        Optional<String> id = values.take();\n        assertThat(id.isPresent(), is(false));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void doesNotFireConnectErrorIfWeForceDisconnectInOpeningState() throws InterruptedException {\n        final BlockingQueue<Optional> values = new LinkedBlockingQueue<>();\n        IO.Options opts = new IO.Options();\n        opts.timeout = 100;\n        socket = client(opts);\n        socket.on(Socket.EVENT_CONNECT_ERROR, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                values.offer(Optional.of(new Error(\"Unexpected\")));\n            }\n        });\n        socket.connect();\n        socket.disconnect();\n\n        new Timer().schedule(new TimerTask() {\n            @Override\n            public void run() {\n                values.offer(Optional.empty());\n            }\n        }, 300);\n\n        @SuppressWarnings(\"unchecked\")\n        Optional<Error> err = values.take();\n        if (err.isPresent()) throw err.get();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldChangeSocketIdUponReconnection() throws InterruptedException {\n        final BlockingQueue<Optional> values = new LinkedBlockingQueue<>();\n        socket = client();\n        socket.once(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                values.offer(Optional.ofNullable(socket.id()));\n\n                socket.io().on(Manager.EVENT_RECONNECT_ATTEMPT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... objects) {\n                        values.offer(Optional.ofNullable(socket.id()));\n                    }\n                });\n\n                socket.once(Socket.EVENT_CONNECT, new Emitter.Listener() {\n                    @Override\n                    public void call(Object... objects) {\n                        values.offer(Optional.ofNullable(socket.id()));\n                    }\n                });\n\n                socket.io().engine.close();\n            }\n        });\n        socket.connect();\n        @SuppressWarnings(\"unchecked\")\n        Optional<String> id1 = values.take();\n\n        @SuppressWarnings(\"unchecked\")\n        Optional<String> id2 = values.take();\n        assertThat(id2.isPresent(), is(false));\n\n        @SuppressWarnings(\"unchecked\")\n        Optional<String> id3 = values.take();\n        assertThat(id3.get(), is(not(id1.get())));\n\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldAcceptAQueryStringOnDefaultNamespace() throws InterruptedException, JSONException {\n        final BlockingQueue<Optional> values = new LinkedBlockingQueue<>();\n\n        socket = client(\"/?c=d\");\n        socket.emit(\"getHandshake\", new Ack() {\n            @Override\n            public void call(Object... args) {\n                JSONObject handshake = (JSONObject)args[0];\n                values.offer(Optional.ofNullable(handshake));\n            }\n        });\n        socket.connect();\n\n        @SuppressWarnings(\"unchecked\")\n        Optional<JSONObject> handshake = values.take();\n        assertThat(handshake.get().getJSONObject(\"query\").getString(\"c\"), is(\"d\"));\n\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldAcceptAQueryString() throws InterruptedException, JSONException {\n        final BlockingQueue<Optional> values = new LinkedBlockingQueue<>();\n\n        socket = client(\"/abc?b=c&d=e\");\n        socket.on(\"handshake\", new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                JSONObject handshake = (JSONObject)args[0];\n                values.offer(Optional.ofNullable(handshake));\n            }\n        });\n        socket.connect();\n\n        @SuppressWarnings(\"unchecked\")\n        Optional<JSONObject> handshake = values.take();\n        JSONObject query = handshake.get().getJSONObject(\"query\");\n        assertThat(query.getString(\"b\"), is(\"c\"));\n        assertThat(query.getString(\"d\"), is(\"e\"));\n\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldAcceptAnAuthOption() throws InterruptedException, JSONException {\n        final BlockingQueue<Optional> values = new LinkedBlockingQueue<>();\n\n        IO.Options opts = new IO.Options();\n        opts.auth = singletonMap(\"token\", \"abcd\");\n        socket = client(\"/abc\", opts);\n        socket.on(\"handshake\", new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                JSONObject handshake = (JSONObject)args[0];\n                values.offer(Optional.ofNullable(handshake));\n            }\n        });\n        socket.connect();\n\n        @SuppressWarnings(\"unchecked\")\n        Optional<JSONObject> handshake = values.take();\n        JSONObject query = handshake.get().getJSONObject(\"auth\");\n        assertThat(query.getString(\"token\"), is(\"abcd\"));\n\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldFireAnErrorEventOnMiddlewareFailure() throws InterruptedException, JSONException {\n        final BlockingQueue<Optional> values = new LinkedBlockingQueue<>();\n\n        socket = client(\"/no\");\n        socket.on(Socket.EVENT_CONNECT_ERROR, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                values.offer(Optional.ofNullable(args[0]));\n            }\n        });\n        socket.connect();\n\n        @SuppressWarnings(\"unchecked\")\n        JSONObject error = ((Optional<JSONObject>) values.take()).get();\n        assertThat(error.getString(\"message\"), is(\"auth failed\"));\n        assertThat(error.getJSONObject(\"data\").getString(\"a\"), is(\"b\"));\n        assertThat(error.getJSONObject(\"data\").getInt(\"c\"), is(3));\n\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldThrowOnReservedEvent() {\n        final BlockingQueue<Optional> values = new LinkedBlockingQueue<>();\n\n        socket = client(\"/no\");\n        try {\n            socket.emit(\"disconnecting\", \"goodbye\");\n            fail();\n        } catch (RuntimeException e) {\n            assertThat(e.getMessage(), is(\"'disconnecting' is a reserved event name\"));\n        }\n\n        socket.disconnect();\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldEmitEventsInOrder() throws InterruptedException {\n        final BlockingQueue<String> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... objects) {\n                socket.emit(\"ack\", \"second\", new Ack() {\n                    @Override\n                    public void call(Object... args) {\n                        values.offer((String) args[0]);\n                    }\n                });\n            }\n        });\n\n        socket.emit(\"ack\", \"first\", new Ack() {\n            @Override\n            public void call(Object... args) {\n                values.offer((String) args[0]);\n            }\n        });\n\n        socket.connect();\n        assertThat(values.take(), is(\"first\"));\n        assertThat(values.take(), is(\"second\"));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldTimeoutAfterTheGivenDelayWhenSocketIsNotConnected() throws InterruptedException {\n        final BlockingQueue<Boolean> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n\n        socket.emit(\"event\", new AckWithTimeout(50) {\n            @Override\n            public void onSuccess(Object... args) {\n                fail();\n            }\n\n            @Override\n            public void onTimeout() {\n                values.offer(true);\n            }\n        });\n\n        assertThat(values.take(), is(true));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldTimeoutWhenTheServerDoesNotAcknowledgeTheEvent() throws InterruptedException {\n        final BlockingQueue<Boolean> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.emit(\"unknown\", new AckWithTimeout(50) {\n                    @Override\n                    public void onTimeout() {\n                        values.offer(true);\n                    }\n\n                    @Override\n                    public void onSuccess(Object... args) {\n                        fail();\n                    }\n                });\n            }\n        });\n\n        socket.connect();\n\n        assertThat(values.take(), is(true));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldTimeoutWhenTheServerDoesNotAcknowledgeTheEventInTime() throws InterruptedException {\n        final BlockingQueue<Boolean> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.emit(\"ack\", new AckWithTimeout(0) {\n                    @Override\n                    public void onTimeout() {\n                        values.offer(true);\n                    }\n\n                    @Override\n                    public void onSuccess(Object... args) {\n                        fail();\n                    }\n                });\n            }\n        });\n\n        socket.connect();\n\n        assertThat(values.take(), is(true));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldNotTimeoutWhenTheServerDoesAcknowledgeTheEvent() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.emit(\"ack\", 1, \"2\", new byte[] { 3 }, new AckWithTimeout(200) {\n                    @Override\n                    public void onTimeout() {\n                        fail();\n                    }\n\n                    @Override\n                    public void onSuccess(Object... args) {\n                        for (Object arg : args) {\n                            values.offer(arg);\n                        }\n                    }\n                });\n            }\n        });\n\n        socket.connect();\n\n        assertThat((Integer) values.take(), is(1));\n        assertThat((String) values.take(), is(\"2\"));\n        assertThat((byte[]) values.take(), is(new byte[] { 3 }));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldCallCatchAllListenerForIncomingPackets() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n\n        socket.on(\"message\", new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                socket.emit(\"echo\", 1, \"2\", new byte[] { 3 });\n\n                socket.onAnyIncoming(new Emitter.Listener() {\n                    @Override\n                    public void call(Object... args) {\n                        for (Object arg : args) {\n                            values.offer(arg);\n                        }\n                    }\n                });\n            }\n        });\n\n        socket.connect();\n\n        assertThat((String) values.take(), is(\"echoBack\"));\n        assertThat((Integer) values.take(), is(1));\n        assertThat((String) values.take(), is(\"2\"));\n        assertThat((byte[]) values.take(), is(new byte[] { 3 }));\n    }\n\n    @Test(timeout = TIMEOUT)\n    public void shouldCallCatchAllListenerForOutgoingPackets() throws InterruptedException {\n        final BlockingQueue<Object> values = new LinkedBlockingQueue<>();\n\n        socket = client();\n\n        socket.emit(\"echo\", 1, \"2\", new byte[] { 3 });\n\n        socket.onAnyOutgoing(new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                for (Object arg : args) {\n                    values.offer(arg);\n                }\n            }\n        });\n\n        socket.connect();\n\n        assertThat((String) values.take(), is(\"echo\"));\n        assertThat((Integer) values.take(), is(1));\n        assertThat((String) values.take(), is(\"2\"));\n        assertThat((byte[]) values.take(), is(new byte[] { 3 }));\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "UrlTest.java",
                                              "content": "package io.socket.client;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport java.net.URI;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.not;\nimport static org.junit.Assert.assertThat;\n\n@RunWith(JUnit4.class)\npublic class UrlTest {\n\n    private URI parse(String uri) {\n        return Url.parse(URI.create(uri)).uri;\n    }\n\n    private String extractId(String uri) {\n        return Url.parse(URI.create(uri)).id;\n    }\n\n    @Test\n    public void parse() {\n        assertThat(parse(\"http://username:password@host:8080/directory/file?query#ref\").toString(),\n                is(\"http://username:password@host:8080/directory/file?query#ref\"));\n    }\n\n    @Test\n    public void parseRelativePath() {\n        URI uri = parse(\"https://woot.com/test\");\n        assertThat(uri.getScheme(), is(\"https\"));\n        assertThat(uri.getHost(), is(\"woot.com\"));\n        assertThat(uri.getPath(), is(\"/test\"));\n    }\n\n    @Test\n    public void parseNoProtocol() {\n        URI uri = parse(\"//localhost:3000\");\n        assertThat(uri.getScheme(), is(\"https\"));\n        assertThat(uri.getHost(), is(\"localhost\"));\n        assertThat(uri.getPort(), is(3000));\n    }\n\n    @Test\n    public void parseNamespace() {\n        assertThat(parse(\"http://woot.com/woot\").getPath(), is(\"/woot\"));\n        assertThat(parse(\"http://google.com\").getPath(), is(\"/\"));\n        assertThat(parse(\"http://google.com/\").getPath(), is(\"/\"));\n    }\n\n    @Test\n    public void parseDefaultPort() {\n        assertThat(parse(\"http://google.com/\").toString(), is(\"http://google.com:80/\"));\n        assertThat(parse(\"https://google.com/\").toString(), is(\"https://google.com:443/\"));\n    }\n\n    @Test\n    public void testWsProtocol() {\n        URI uri = parse(\"ws://woot.com/test\");\n        assertThat(uri.getScheme(), is(\"ws\"));\n        assertThat(uri.getHost(), is(\"woot.com\"));\n        assertThat(uri.getPort(), is(80));\n        assertThat(uri.getPath(), is(\"/test\"));\n    }\n\n    @Test\n    public void testWssProtocol() {\n        URI uri = parse(\"wss://woot.com/test\");\n        assertThat(uri.getScheme(), is(\"wss\"));\n        assertThat(uri.getHost(), is(\"woot.com\"));\n        assertThat(uri.getPort(), is(443));\n        assertThat(uri.getPath(), is(\"/test\"));\n    }\n\n    @Test\n    public void extractId() {\n        String id1 = extractId(\"http://google.com:80/\");\n        String id2 = extractId(\"http://google.com/\");\n        String id3 = extractId(\"https://google.com/\");\n        assertThat(id1, is(id2));\n        assertThat(id1, is(not(id3)));\n        assertThat(id2, is(not(id3)));\n    }\n\n    @Test\n    public void ipv6() {\n        String url = \"http://[::1]\";\n        URI parsed = parse(url);\n        assertThat(parsed.getScheme(), is(\"http\"));\n        assertThat(parsed.getHost(), is(\"[::1]\"));\n        assertThat(parsed.getPort(), is(80));\n        assertThat(extractId(url), is(\"http://[::1]:80\"));\n    }\n\n}\n"
                                            }
                                          },
                                          {
                                            "directory": {
                                              "path": "executions",
                                              "content": [
                                                {
                                                  "javaFile": {
                                                    "path": "Connection.java",
                                                    "content": "package io.socket.client.executions;\n\nimport io.socket.emitter.Emitter;\nimport io.socket.client.IO;\nimport io.socket.client.Socket;\nimport okhttp3.OkHttpClient;\n\nimport java.net.URISyntaxException;\n\npublic class Connection {\n\n    public static void main(String[] args) throws URISyntaxException {\n        IO.Options options = new IO.Options();\n        options.forceNew = true;\n\n        final OkHttpClient client = new OkHttpClient();\n        options.webSocketFactory = client;\n        options.callFactory = client;\n\n        final Socket socket = IO.socket(\"http://localhost:\" + System.getenv(\"PORT\"), options);\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                System.out.println(\"connect\");\n                socket.close();\n            }\n        });\n        socket.io().on(io.socket.engineio.client.Socket.EVENT_CLOSE, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                System.out.println(\"engine close\");\n                client.dispatcher().executorService().shutdown();\n            }\n        });\n        socket.open();\n    }\n}\n"
                                                  }
                                                },
                                                {
                                                  "javaFile": {
                                                    "path": "ConnectionFailure.java",
                                                    "content": "package io.socket.client.executions;\n\nimport io.socket.emitter.Emitter;\nimport io.socket.client.IO;\nimport io.socket.client.Socket;\nimport okhttp3.OkHttpClient;\n\nimport java.net.URISyntaxException;\n\npublic class ConnectionFailure {\n\n    public static void main(String[] args) throws URISyntaxException {\n        int port = Integer.parseInt(System.getenv(\"PORT\"));\n        port++;\n        IO.Options options = new IO.Options();\n        options.forceNew = true;\n        options.reconnection = false;\n\n        final OkHttpClient client = new OkHttpClient();\n        options.webSocketFactory = client;\n        options.callFactory = client;\n\n        final Socket socket = IO.socket(\"http://localhost:\" + port, options);\n        socket.on(Socket.EVENT_CONNECT_ERROR, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                System.out.println(\"connect error\");\n                client.dispatcher().executorService().shutdown();\n            }\n        }).on(Socket.EVENT_DISCONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                System.out.println(\"disconnect\");\n            }\n        });\n        socket.open();\n    }\n}\n"
                                                  }
                                                },
                                                {
                                                  "javaFile": {
                                                    "path": "ImmediateClose.java",
                                                    "content": "package io.socket.client.executions;\n\nimport io.socket.emitter.Emitter;\nimport io.socket.client.IO;\nimport io.socket.client.Socket;\nimport okhttp3.OkHttpClient;\n\nimport java.net.URISyntaxException;\n\npublic class ImmediateClose {\n\n    public static void main(String[] args) throws URISyntaxException {\n        IO.Options options = new IO.Options();\n        options.forceNew = true;\n\n        final OkHttpClient client = new OkHttpClient();\n        options.webSocketFactory = client;\n        options.callFactory = client;\n\n        final Socket socket = IO.socket(\"http://localhost:\" + System.getenv(\"PORT\"), options);\n        socket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                System.out.println(\"connect\");\n            }\n        }).on(Socket.EVENT_DISCONNECT, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                System.out.println(\"disconnect\");\n            }\n        });\n        socket.io().on(io.socket.engineio.client.Socket.EVENT_CLOSE, new Emitter.Listener() {\n            @Override\n            public void call(Object... args) {\n                System.out.println(\"engine close\");\n                client.dispatcher().executorService().shutdown();\n            }\n        });\n        socket.connect();\n        socket.disconnect();\n    }\n}\n"
                                                  }
                                                }
                                              ]
                                            }
                                          }
                                        ]
                                      }
                                    },
                                    {
                                      "directory": {
                                        "path": "hasbinary",
                                        "content": [
                                          {
                                            "javaFile": {
                                              "path": "HasBinaryTest.java",
                                              "content": "package io.socket.hasbinary;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport java.nio.charset.Charset;\n\nimport static org.junit.Assert.assertTrue;\n\n@RunWith(JUnit4.class)\npublic class HasBinaryTest {\n\n    @Test\n    public void byteArray() {\n        assertTrue(HasBinary.hasBinary(new byte[0]));\n    }\n\n    @Test\n    public void anArrayThatDoesNotContainByteArray() throws JSONException {\n        JSONArray arr = new JSONArray(\"[1, \\\"cool\\\", 2]\");\n        assertTrue(!HasBinary.hasBinary(arr));\n    }\n\n    @Test\n    public void anArrayContainsByteArray() throws JSONException {\n        JSONArray arr = new JSONArray(\"[1, null, 2]\");\n        arr.put(1, \"asdfasdf\".getBytes(Charset.forName(\"UTF-8\")));\n        assertTrue(HasBinary.hasBinary(arr));\n    }\n\n    @Test\n    public void anObjectThatDoesNotContainByteArray() throws JSONException {\n        JSONObject ob = new JSONObject(\"{\\\"a\\\": \\\"a\\\", \\\"b\\\": [], \\\"c\\\": 1234}\");\n        assertTrue(!HasBinary.hasBinary(ob));\n    }\n\n    @Test\n    public void anObjectThatContainsByteArray() throws JSONException {\n        JSONObject ob = new JSONObject(\"{\\\"a\\\": \\\"a\\\", \\\"b\\\": null, \\\"c\\\": 1234}\");\n        ob.put(\"b\", \"abc\".getBytes(Charset.forName(\"UTF-8\")));\n        assertTrue(HasBinary.hasBinary(ob));\n    }\n\n    @Test\n    public void testNull() {\n        assertTrue(!HasBinary.hasBinary(null));\n    }\n\n    @Test\n    public void aComplexObjectThatContainsNoBinary() throws JSONException {\n        JSONObject ob = new JSONObject();\n        ob.put(\"x\", new JSONArray(\"[\\\"a\\\", \\\"b\\\", 123]\"));\n        ob.put(\"y\", JSONObject.NULL);\n        ob.put(\"z\", new JSONObject(\"{\\\"a\\\": \\\"x\\\", \\\"b\\\": \\\"y\\\", \\\"c\\\": 3, \\\"d\\\": null}\"));\n        ob.put(\"w\", new JSONArray());\n        assertTrue(!HasBinary.hasBinary(ob));\n    }\n\n    @Test\n    public void aComplexObjectThatContainsBinary() throws JSONException {\n        JSONObject ob = new JSONObject();\n        ob.put(\"x\", new JSONArray(\"[\\\"a\\\", \\\"b\\\", 123]\"));\n        ob.put(\"y\", JSONObject.NULL);\n        ob.put(\"z\", new JSONObject(\"{\\\"a\\\": \\\"x\\\", \\\"b\\\": \\\"y\\\", \\\"c\\\": 3, \\\"d\\\": null}\"));\n        ob.put(\"w\", new JSONArray());\n        ob.put(\"bin\", \"xxx\".getBytes(Charset.forName(\"UTF-8\")));\n        assertTrue(HasBinary.hasBinary(ob));\n    }\n}\n"
                                            }
                                          }
                                        ]
                                      }
                                    },
                                    {
                                      "directory": {
                                        "path": "parser",
                                        "content": [
                                          {
                                            "javaFile": {
                                              "path": "ByteArrayTest.java",
                                              "content": "package io.socket.parser;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\n\nimport static java.util.Arrays.asList;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertThat;\n\n@RunWith(JUnit4.class)\npublic class ByteArrayTest {\n\n    private static Parser.Encoder encoder = new IOParser.Encoder();\n\n    @Test\n    public void encodeByteArray() throws JSONException {\n        Packet<JSONArray> packet = new Packet<>(Parser.BINARY_EVENT);\n        packet.data = new JSONArray(asList(\"abc\", \"abc\".getBytes(StandardCharsets.UTF_8)));\n        packet.id = 23;\n        packet.nsp = \"/cool\";\n        Helpers.testBin(packet);\n    }\n\n    @Test\n    public void encodeByteArray2() {\n        Packet<JSONArray> packet = new Packet<>(Parser.BINARY_EVENT);\n        packet.data = new JSONArray(asList(\"2\", new byte[] { 0, 1 }));\n        packet.id = 0;\n        packet.nsp = \"/\";\n        Helpers.testBin(packet);\n    }\n\n    @Test\n    public void encodeByteArrayDeepInJson() throws JSONException {\n        JSONArray data = new JSONArray(\"[{a: \\\"hi\\\", b: {}, c: {a: \\\"bye\\\", b: {}}}]\");\n        data.getJSONObject(0).getJSONObject(\"b\").put(\"why\", new byte[3]);\n        data.getJSONObject(0).getJSONObject(\"c\").getJSONObject(\"b\").put(\"a\", new byte[6]);\n\n        Packet<JSONArray> packet = new Packet<>(Parser.BINARY_EVENT);\n        packet.data = data;\n        packet.id = 999;\n        packet.nsp = \"/deep\";\n        Helpers.testBin(packet);\n    }\n\n    @Test\n    public void encodeDeepBinaryJSONWithNullValue() throws JSONException {\n        JSONArray data = new JSONArray(\"[{a: \\\"b\\\", c: 4, e: {g: null}, h: null}]\");\n        data.getJSONObject(0).put(\"h\", new byte[9]);\n\n        Packet<JSONArray> packet = new Packet<>(Parser.BINARY_EVENT);\n        packet.data = data;\n        packet.nsp = \"/\";\n        packet.id = 600;\n        Helpers.testBin(packet);\n    }\n\n    @Test\n    public void encodeBinaryAckWithByteArray() throws JSONException {\n        JSONArray data = new JSONArray(\"[a, null, {}]\");\n        data.put(1, \"xxx\".getBytes(Charset.forName(\"UTF-8\")));\n\n        Packet<JSONArray> packet = new Packet<>(Parser.BINARY_ACK);\n        packet.data = data;\n        packet.id = 127;\n        packet.nsp = \"/back\";\n        Helpers.testBin(packet);\n    }\n\n    @Test\n    public void cleanItselfUpOnClose() {\n        JSONArray data = new JSONArray();\n        data.put(new byte[2]);\n        data.put(new byte[3]);\n\n        Packet<JSONArray> packet = new Packet<>(Parser.BINARY_EVENT);\n        packet.data = data;\n        packet.id = 0;\n        packet.nsp = \"/\";\n\n        encoder.encode(packet, new Parser.Encoder.Callback() {\n            @Override\n            public void call(final Object[] encodedPackets) {\n                final IOParser.Decoder decoder = new IOParser.Decoder();\n                decoder.onDecoded(new Parser.Decoder.Callback() {\n                    @Override\n                    public void call(Packet packet) {\n                        throw new RuntimeException(\"received a packet when not all binary data was sent.\");\n                    }\n                });\n\n                decoder.add((String)encodedPackets[0]);\n                decoder.add((byte[]) encodedPackets[1]);\n                decoder.destroy();\n                assertThat(decoder.reconstructor.buffers.size(), is(0));\n            }\n        });\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "Helpers.java",
                                              "content": "package io.socket.parser;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport org.skyscreamer.jsonassert.JSONAssert;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.fail;\n\n@RunWith(JUnit4.class)\npublic class Helpers {\n\n    private static Parser.Encoder encoder = new IOParser.Encoder();\n\n    public static void test(final Packet obj) {\n        encoder.encode(obj, new Parser.Encoder.Callback() {\n            @Override\n            public void call(Object[] encodedPackets) {\n                Parser.Decoder decoder = new IOParser.Decoder();\n                decoder.onDecoded(new Parser.Decoder.Callback() {\n                    @Override\n                    public void call(Packet packet) {\n                        assertPacket(packet, obj);\n                    }\n                });\n                decoder.add((String)encodedPackets[0]);\n            }\n        });\n    }\n\n    public static void testDecodeError(final String errorMessage) {\n        Parser.Decoder decoder = new IOParser.Decoder();\n        try {\n            decoder.add(errorMessage);\n            fail();\n        } catch (DecodingException e) {}\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static void testBin(final Packet obj) {\n        final Object originalData = obj.data;\n        encoder.encode(obj, new Parser.Encoder.Callback() {\n            @Override\n            public void call(Object[] encodedPackets) {\n                Parser.Decoder decoder = new IOParser.Decoder();\n                decoder.onDecoded(new Parser.Decoder.Callback() {\n                    @Override\n                    public void call(Packet packet) {\n                        obj.data = originalData;\n                        obj.attachments = -1;\n                        assertPacket(packet, obj);\n                    }\n                });\n\n                for (Object packet : encodedPackets) {\n                    if (packet instanceof String) {\n                        decoder.add((String)packet);\n                    } else if (packet instanceof byte[]) {\n                        decoder.add((byte[])packet);\n                    }\n                }\n            }\n        });\n    }\n\n    public static void assertPacket(Packet expected, Packet actual) {\n        assertThat(actual.type, is(expected.type));\n        assertThat(actual.id, is(expected.id));\n        assertThat(actual.nsp, is(expected.nsp));\n        assertThat(actual.attachments, is(expected.attachments));\n\n        if (expected.data instanceof JSONArray) {\n            try {\n                JSONAssert.assertEquals((JSONArray)expected.data, (JSONArray)actual.data, true);\n            } catch (JSONException e) {\n                throw new AssertionError(e);\n            }\n        } else if (expected.data instanceof JSONObject) {\n            try {\n                JSONAssert.assertEquals((JSONObject)expected.data, (JSONObject)actual.data, true);\n            } catch (JSONException e) {\n                throw new AssertionError(e);\n            }\n        } else {\n            assertThat(actual.data, is(expected.data));\n        }\n    }\n}\n"
                                            }
                                          },
                                          {
                                            "javaFile": {
                                              "path": "ParserTest.java",
                                              "content": "package io.socket.parser;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class ParserTest {\n\n    private static Parser.Encoder encoder = new IOParser.Encoder();\n\n    @Test\n    public void encodeConnection() {\n        Packet packet = new Packet(Parser.CONNECT);\n        packet.nsp = \"/woot\";\n        Helpers.test(packet);\n    }\n\n    @Test\n    public void encodeDisconnection() {\n        Packet packet = new Packet(Parser.DISCONNECT);\n        packet.nsp = \"/woot\";\n        Helpers.test(packet);\n    }\n\n    @Test\n    public void encodeEvent() throws JSONException {\n        Packet<JSONArray> packet1 = new Packet<>(Parser.EVENT);\n        packet1.data = new JSONArray(\"[\\\"a\\\", 1, {}]\");\n        packet1.nsp = \"/\";\n        Helpers.test(packet1);\n\n        Packet<JSONArray> packet2 = new Packet<>(Parser.EVENT);\n        packet2.data = new JSONArray(\"[\\\"a\\\", 1, {}]\");\n        packet2.nsp = \"/test\";\n        Helpers.test(packet2);\n    }\n\n    @Test\n    public void encodeAck() throws JSONException {\n        Packet<JSONArray> packet = new Packet<>(Parser.ACK);\n        packet.data = new JSONArray(\"[\\\"a\\\", 1, {}]\");\n        packet.id = 123;\n        packet.nsp = \"/\";\n        Helpers.test(packet);\n    }\n\n    @Test\n    public void decodeInError() throws JSONException {\n        // Random string\n        Helpers.testDecodeError(\"asdf\");\n        // Unknown type\n        Helpers.testDecodeError(Parser.types.length + \"asdf\");\n        // Binary event with no `-`\n        Helpers.testDecodeError(Parser.BINARY_EVENT + \"asdf\");\n        // Binary ack with no `-`\n        Helpers.testDecodeError(Parser.BINARY_ACK + \"asdf\");\n        // Binary event with no attachment\n        Helpers.testDecodeError(String.valueOf(Parser.BINARY_EVENT));\n        // event non numeric id\n        Helpers.testDecodeError(Parser.EVENT + \"2sd\");\n        // event with invalid json data\n        Helpers.testDecodeError(Parser.EVENT + \"2[\\\"a\\\",1,{asdf}]\");\n        Helpers.testDecodeError(Parser.EVENT + \"2{}\");\n        Helpers.testDecodeError(Parser.EVENT + \"2[]\");\n        Helpers.testDecodeError(Parser.EVENT + \"2[null]\");\n    }\n}\n"
                                            }
                                          }
                                        ]
                                      }
                                    },
                                    {
                                      "directory": {
                                        "path": "util",
                                        "content": [
                                          {
                                            "javaFile": {
                                              "path": "Optional.java",
                                              "content": "package io.socket.util;\n\nimport java.util.NoSuchElementException;\n\npublic class Optional<T> {\n\n    static final Optional<Void> EMPTY = Optional.ofNullable(null);\n\n    private T value;\n\n    public static <T> Optional<T> of(T value) {\n        if (value == null) {\n            throw new NullPointerException();\n        }\n        return new Optional<>(value);\n    }\n\n    public static <T> Optional<T> ofNullable(T value) {\n        return new Optional<>(value);\n    }\n\n    public static Optional<Void> empty() {\n        return EMPTY;\n    }\n\n    private Optional(T value) {\n        this.value = value;\n    }\n\n    public boolean isPresent() {\n        return this.value != null;\n    }\n\n    public T get() {\n        if (this.value == null) {\n            throw new NoSuchElementException();\n        }\n        return this.value;\n    }\n\n    public T orElse(T other) {\n        return this.value != null ? this.value : other;\n    }\n}\n"
                                            }
                                          }
                                        ]
                                      }
                                    }
                                  ]
                                }
                              }
                            ]
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    ]
  }
};
